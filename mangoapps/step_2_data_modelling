2ï¸âƒ£ Data Modeling (Courses, Programs, Enrollments)
â“ Question theyâ€™ll ask

â€œHow did you model courses, programs, and enrollments in the LMS?â€

âœ… Strong, clear answer (this is your base answer)

â€œWe modeled Users, Courses, and Programs as core entities.
Since users can enroll in multiple courses and programsâ€”and each course or program can have many usersâ€”we introduced separate enrollment tables to handle these many-to-many relationships.

This allowed us to store enrollment-specific data like status, progress, completion dates, and audit information without polluting the core entities.â€

This immediately shows good relational thinking.

ğŸ§± Typical tables (you donâ€™t need to show code, just concept)

users

courses

programs

course_enrollments

program_enrollments

Each enrollment table had:

user_id

course_id / program_id

status (enrolled, completed, dropped)

progress / completion info

timestamps

ğŸ§  Why this design matters (what theyâ€™re testing)

Do you understand many-to-many relationships

Can you attach behavior & state to relationships

Are you thinking about future features

ğŸ” Follow-up questions they WILL ask
1ï¸âƒ£ â€œWhy separate course_enrollments and program_enrollments?â€

Answer:

â€œCourses and programs had different lifecycles and business rules.
Programs could span multiple courses and have their own completion logic, so separating them kept the data model simpler and avoided conditional logic inside a single table.â€

2ï¸âƒ£ â€œCould a course belong to multiple programs?â€

Answer:

â€œYes. We used a join table between programs and courses, which allowed us to reuse courses across programs without duplication.â€

This sounds architect-level correct.

3ï¸âƒ£ â€œHow did you prevent duplicate enrollments?â€

Answer:

â€œWe enforced uniqueness at the database level using a composite unique index on user_id and course_id (or program_id).
This ensured data integrity even under concurrent requests.â€

ğŸ¯ DB constraints = big plus.

4ï¸âƒ£ â€œWhere did progress live?â€

Answer:

â€œProgress was stored on the enrollment record rather than the course or user, since progress is specific to a userâ€™s enrollment in that course or program.â€

Thatâ€™s the right answer.

ğŸ§  Architect push question
â€œWhy not just store course_id on users?â€

Answer:

â€œThat wouldnâ€™t scale well because users can enroll in many courses, and weâ€™d lose the ability to track enrollment-specific metadata like progress, status, and history.â€

âš ï¸ Mistakes to avoid

âŒ â€œWe just used HABTMâ€

âŒ â€œWe added columns later when neededâ€

âŒ â€œApplication-level checks onlyâ€

Always mention DB-level safety.

Bonus: advanced touch (only if they push)

â€œWe also considered historical correctnessâ€”if a course was updated later, enrollment records preserved the userâ€™s state at the time of enrollment.â€

This shows long-term thinking.

20-second summary (if they want it fast)

â€œWe used enrollment tables to model many-to-many relationships and store enrollment-specific state like progress and status.
Database constraints ensured uniqueness and consistency, while separate models kept course and program logic clean.â€

Next step ğŸ‘‡
Say â€œnext: roles & authorizationâ€
Thatâ€™s where architects test security + design maturity ğŸ”