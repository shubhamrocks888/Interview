ğŸ¥ Video Handling Flow â€“ Mental Diagram (Memorize This)
1ï¸âƒ£ Admin uploads video (RAW ASSET)
Admin Browser
     â†“
Pre-signed URL
     â†“
Object Storage (S3 / GCS)


What this means:

Video is only stored

Not playable yet

No duration

No streaming

ğŸ‘‰ State: uploaded

2ï¸âƒ£ Storage event triggers processing
Object Storage
     â†“ (event)
Background Worker


What happens:

System is notified that a new file exists

No user is waiting

Fully async

ğŸ‘‰ Reason: heavy work must not block requests

3ï¸âƒ£ Video processing (PREPARATION)
Raw Video
   â†“
Normalize format
   â†“
Split into chunks
   â†“
Create multiple qualities
   â†“
Extract metadata


Results:

Browser-compatible format

Streaming support

Duration known

Thumbnails created

ğŸ‘‰ State: processing

4ï¸âƒ£ Video becomes STREAM-READY
Processed Video
     â†“
CDN


Database updated:

duration

playback URL

status = ready

ğŸ‘‰ Now it is playable

5ï¸âƒ£ Admin publishes chapter
Video ready
     â†“
Chapter published


Why separate step?

Avoid exposing broken content

Admin controls visibility

6ï¸âƒ£ Learner plays video
Learner
   â†“ (request)
Rails (authorize)
   â†“
Signed URL
   â†“
CDN (streams video)


Rails:

Does NOT stream video

Only authorizes access

7ï¸âƒ£ Progress tracking
Player
   â†“ (heartbeat)
Rails
   â†“
Progress table


Used for:

Resume playback

Completion %

Course & program progress

ğŸ§  One-paragraph interview answer (memorize)

â€œVideo upload is a two-phase process.
First, the raw video is uploaded directly to object storage using a pre-signed URL.
Second, a background worker processes the video into streaming-optimized formats, extracts metadata like duration, and prepares adaptive bitrates.
Only after processing and publishing is the video available to learners, while Rails handles authorization and progress tracking.â€

ğŸ”¥ If architect pushes further

If they say:

â€œWhy not just store and play the uploaded file?â€

You answer:

â€œRaw videos are inconsistent, heavy, and not streaming-friendly.
Processing ensures reliability, scalability, and accurate progress tracking.â€