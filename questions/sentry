ğŸ”¥ What is Sentry?

Sentry is an error monitoring and application observability tool used to:

Capture runtime exceptions

Track production bugs

Provide stack traces + context

Help teams detect, triage, and fix issues faster

ğŸ‘‰ In short:
Logs tell you what happened, Sentry tells you why it broke and where.

ğŸ§  Why Sentry is needed (Problem it solves)

In production:

You cannot reproduce user-specific issues easily

Logs may be incomplete or noisy

Bugs may happen only under specific conditions

Sentry solves this by:

Automatically capturing uncaught exceptions

Attaching rich context (user, request, params, environment)

Grouping similar errors

Alerting teams in real time

ğŸ—ï¸ How Sentry Works (Internals â€“ Interview Gold)
1ï¸âƒ£ Exception occurs

Example:

NoMethodError: undefined method `name' for nil:NilClass

2ï¸âƒ£ Sentry SDK intercepts it

Rails middleware / background job wrapper catches the exception

Works for:

Controller requests

Background jobs (Sidekiq, ActiveJob)

Cron jobs

3ï¸âƒ£ Event is created

Sentry builds an event payload containing:

Stack trace

File & line number

Exception type & message

Request details

Environment info

4ï¸âƒ£ Event is sent to Sentry server

Sent asynchronously

Non-blocking

Uses HTTPS

5ï¸âƒ£ Error grouping & fingerprinting

Sentry groups similar errors using:

Exception type

Stack trace

Fingerprint

So 10,000 identical errors â†’ 1 issue, not 10,000 alerts.

ğŸ”Œ Sentry in Rails (How it integrates)
Installation
gem 'sentry-ruby'
gem 'sentry-rails'

Configuration
Sentry.init do |config|
  config.dsn = ENV['SENTRY_DSN']
  config.environment = Rails.env
end

What it captures automatically

âœ… Controller exceptions
âœ… Middleware failures
âœ… ActiveJob / Sidekiq errors
âœ… Rack request context

ğŸ“¦ What Data Sentry Captures (Very Important)
1ï¸âƒ£ Stack Trace

Shows:

Exact file

Line number

Method chain

This answers: â€œWhere did it break?â€

2ï¸âƒ£ Request Context

HTTP method

URL

Params (filtered)

Headers

IP address

Rails example:

POST /orders
params: { product_id: 12, quantity: 3 }

3ï¸âƒ£ User Context
Sentry.set_user(id: current_user.id, email: current_user.email)


Allows you to answer:

â€œWhich users are affected?â€

4ï¸âƒ£ Environment & Tags

Rails env (production)

Hostname

Release version

Sentry.set_tag("feature", "checkout")

5ï¸âƒ£ Breadcrumbs (Super Important)

Breadcrumbs are steps before the crash:

SQL queries

HTTP calls

Background job execution

Logs

Think of them as:

â€œFlight recorder before the crashâ€

ğŸ” Sentry + Background Jobs (Sidekiq)

Sentry automatically captures:

Job class

Arguments

Retry count

Queue name

Example:

â€œPaymentJob failed after 3 retries due to Stripe API timeout.â€

This is critical for async systems.

ğŸš¨ Alerts & Notifications

Sentry can notify via:

Slack

Email

PagerDuty

Alert triggers:

New issue

Error rate spike

Regression

Example:

â€œError started after deploy v1.2.4â€

ğŸ§© Release Tracking (Advanced)

Sentry tracks:

Which release introduced a bug

Which release fixed it

config.release = "my-app@1.3.0"


This is extremely useful during deployments.

ğŸ› ï¸ Manual Error Capture
Capture handled exceptions
begin
  risky_call
rescue => e
  Sentry.capture_exception(e)
end

Capture custom messages
Sentry.capture_message("Unexpected state reached")

ğŸ” Security & Data Safety

Sensitive params filtered (password, token)

PII scrubbing

GDPR compliant

On-prem option available

ğŸ§ª Sentry vs Logs (Interview Comparison)
Logs	Sentry
Text-based	Structured events
Hard to correlate	Automatic grouping
No stack trace	Full stack trace
Manual search	Instant issue view
ğŸ§  Real-world example (Say this in interview)

â€œWe noticed checkout failures in production. Sentry showed a NilClass error with breadcrumbs pointing to a missing API response key. We added validation and fallback logic, and the issue stopped.â€

ğŸ§¾ One-liner definition (Memorize this)

â€œSentry is an error monitoring platform that captures runtime exceptions with full contextâ€”stack trace, request data, and user informationâ€”allowing teams to detect, debug, and fix production issues faster.â€

ğŸ¯ Common Follow-up Questions (Be Ready)

Q: Does Sentry replace logs?
â¡ï¸ No. It complements logs.

Q: Performance impact?
â¡ï¸ Minimal, events are sent asynchronously.

Q: Difference between Sentry & New Relic?
â¡ï¸ Sentry focuses on errors, New Relic focuses on performance.





####################


ğŸ”¹ 1. Background: Why Sidekiq errors need special handling

Sidekiq jobs run asynchronously, outside of HTTP requests.

Exceptions donâ€™t automatically bubble up to Rails controllers.

Without monitoring, job failures can silently fail, especially in production.

Sentry solves this by wrapping jobs and capturing exceptions automatically.

ğŸ”¹ 2. How Sentry integrates with Sidekiq
Step 1: Add the Sentry Sidekiq integration
# Gemfile
gem 'sentry-ruby'
gem 'sentry-rails'
gem 'sentry-sidekiq'

# config/initializers/sentry.rb
Sentry.init do |config|
  config.dsn = ENV['SENTRY_DSN']
  config.breadcrumbs_logger = [:active_support_logger, :sidekiq_logger]
  config.traces_sample_rate = 0.5
end

Step 2: Middleware injection

Sentry adds Sidekiq middleware internally:

Client middleware â€“ adds context when job is enqueued

Server middleware â€“ wraps job execution and catches exceptions

Simplified flow:

Sidekiq Server â†’ Job Execution â†’ Sentry Middleware â†’ Exception?


If the job raises an exception, Sentry intercepts it, captures the event, and sends it to the Sentry server.

The exception still propagates to Sidekiq so retries behave normally.

ğŸ”¹ 3. What Sentry captures from a Sidekiq job

Job metadata

Job class (PaymentJob)

Queue name (default)

Arguments ({ user_id: 12, amount: 1000 })

Retry count

Stack trace

Where exactly the job failed

Environment & Release info

Rails env (production)

App release version (myapp@1.3.0)

Breadcrumbs leading to failure

Previous jobs, SQL queries, HTTP calls, logs

Optional user context

Sentry.set_user(id: current_user.id)

ğŸ”¹ 4. Example
class PaymentJob < ApplicationJob
  queue_as :default

  def perform(user_id, amount)
    user = User.find(user_id)
    charge = Stripe::Charge.create(amount: amount, customer: user.stripe_id)
  rescue => e
    # Optional manual capture
    Sentry.capture_exception(e)
    raise e # important to let Sidekiq retry
  end
end


If Stripe::Charge.create fails, Sentry automatically logs the exception.

You can see:

Job class, arguments, retry count

Full stack trace

Request context (if available)

Breadcrumbs (DB queries, other jobs, HTTP calls)

ğŸ”¹ 5. Advanced: Job Context & Tags

You can add custom tags or extra context to Sidekiq jobs:

Sentry.set_tags(queue: 'default', job_id: jid)
Sentry.set_extras(custom_param: "value")


This helps in filtering errors in Sentry dashboards.

ğŸ”¹ 6. Alerts & Notifications

Sentry can alert on:

Job failures

Error rate spikes

Regression errors after deploy

Integrates with Slack, PagerDuty, email

ğŸ”¹ 7. Summary for interviews

Sidekiq jobs run outside HTTP context, so errors must be captured specially.

Sentry adds middleware to wrap job execution.

Captures: job class, args, retries, stack trace, breadcrumbs.

Exceptions still propagate to Sidekiq so retries work.

Supports custom context/tags and alerts.

ğŸ’¡ Pro interview tip:
If asked â€œHow does Sentry capture Sidekiq jobs differently from normal controller errors?â€, you can say:

â€œSentry injects middleware around Sidekiq job execution, capturing exceptions, job metadata, and breadcrumbs, whereas controller exceptions are captured via Rails middleware in the request/response cycle. Both feed into the same dashboard for unified monitoring.â€