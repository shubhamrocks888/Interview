class User < ApplicationRecord
  # =====================
  # Associations
  # =====================

  # User who referred me
  belongs_to :referrer,
             class_name: "User",
             foreign_key: :referred_by_id,
             optional: true

  # Users I referred
  has_many :referrals,
           class_name: "User",
           foreign_key: :referred_by_id,
           dependent: :nullify

  # =====================
  # Validations
  # =====================

  validates :email,
            presence: true,
            uniqueness: true,
            format: { with: URI::MailTo::EMAIL_REGEXP }

  validates :full_name, presence: true
end


#### dont undertsand her belongs_to and has_many for self association


Good question ðŸ‘ Self-associations in Rails feel confusing at first, but theyâ€™re actually simple once you visualize them.

You are creating a referral system where:

One user can refer many users

Each user can be referred by one user

So this is a User â†” User relationship.

ðŸ” What Is a Self-Association?

Normally, associations are between two different models:

User has_many :posts
Post belongs_to :user


But here, User is related to User itself.

Think of it like:

Rahul â†’ referred â†’ Amit
Amit  â†’ referred â†’ Neha


All are rows in the same users table.

ðŸ§  Database Structure (Very Important)

Your users table must have:

t.bigint :referred_by_id


So it looks like:

id  full_name email referred_by_id
1 Rahul r@mail.com
  nil
2 Amit  a@mail.com
  1
3 Neha  n@mail.com
  1

Here:

Rahul referred Amit and Neha

So Amit and Neha have referred_by_id = 1

ðŸ”¹ belongs_to :referrer
belongs_to :referrer,
           class_name: "User",
           foreign_key: :referred_by_id,
           optional: true

What this means:

ðŸ‘‰ "This user belongs to another user called referrer."

So for Amit:

amit.referrer


Rails does:

SELECT * FROM users WHERE id = amit.referred_by_id


Which returns Rahul.

Why class_name: "User"?

Because Rails thinks:

belongs_to :referrer


means there should be a model called:

Referrer


But we donâ€™t have a Referrer model.

So we tell Rails:

ðŸ‘‰ "Actually, referrer is also a User."

Why foreign_key: :referred_by_id?

Rails would normally look for:

referrer_id


But your column is:

referred_by_id


So we must tell it explicitly.

Why optional: true?

Because first users (like Rahul) are not referred by anyone.

If we donâ€™t add optional: true, Rails will force every user to have a referrer.

ðŸ”¹ has_many :referrals
has_many :referrals,
         class_name: "User",
         foreign_key: :referred_by_id,
         dependent: :nullify

What this means:

ðŸ‘‰ "This user has many users that were referred by them."

For Rahul:

rahul.referrals


Rails runs:

SELECT * FROM users WHERE referred_by_id = rahul.id


Returns:

[Amit, Neha]

Why again class_name: "User"?

Because:

has_many :referrals


Rails thinks there is a Referral model.

But there isnâ€™t.

So we tell Rails:

ðŸ‘‰ "Referrals are actually Users."

Why same foreign_key?

Because referrals are stored like this:

referred_by_id = rahul.id


So Rails uses that column to find children.

ðŸ” Simple Mental Model

Think of it like:

          (has_many)
Rahul ----------------> Amit
   â†‘                     |
   |                     |
   -------- belongs_to ---


Rahul â†’ has_many :referrals

Amit â†’ belongs_to :referrer

They are opposite sides of the same relationship.

ðŸ”Ž In Plain English
Code  Meaning
belongs_to :referrer  I was referred by someone
has_many :referrals I referred other users
ðŸ§ª Example Usage
rahul = User.create!(full_name: "Rahul", email: "r@mail.com")

amit = User.create!(
  full_name: "Amit",
  email: "a@mail.com",
  referrer: rahul
)

rahul.referrals
# => [amit]

amit.referrer
# => rahul
