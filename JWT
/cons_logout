Short answer (one-liner)

ğŸ‘‰ JWT is stateless, so the server cannot invalidate a token once itâ€™s issued.
Logout becomes a client-side illusion.

What â€œlogoutâ€ really means
In session-based auth (Devise)

Logout = âŒ invalidate session on server

reset_session


Immediately:

Cookie useless

Any further request fails

âœ… Real logout

In JWT-based auth

Logout = âŒ delete token on client

localStorage.removeItem("token")


Butâ€¦

Server still accepts that JWT

Token is valid until exp

ğŸš¨ Anyone holding that token is still logged in

Why server canâ€™t â€œlog outâ€ JWT

JWT verification is:

Verify signature
Check exp
Done


No DB call.
No memory.
No session.

So server has no idea:

Who logged out

Which token should be blocked

Thatâ€™s the cost of statelessness.

Real-world attack scenario ğŸ˜¬

User logs in

JWT issued (valid for 24h)

Token leaked (XSS / logs / proxy)

User clicks â€œLogoutâ€

Attacker still uses JWT for 24h

ğŸ’¥ Logout did NOTHING.

Why people say â€œjust blacklist tokensâ€

Because they realize the problem ğŸ˜„

But blacklisting means:

Store token IDs in DB/Redis

Check blacklist on every request

Which results in:
âŒ Stateful system
âŒ Extra DB/Redis hit
âŒ Defeats JWTâ€™s main benefit

Common workarounds (all have tradeoffs)
1ï¸âƒ£ Short-lived access tokens
exp = 5â€“15 minutes


Limits damage but:

Still not instant logout

Requires refresh token system

2ï¸âƒ£ Refresh tokens (more complexity)

Access token short-lived

Refresh token stored server-side

Rotate refresh tokens

Still:

Access token remains valid until expiry

3ï¸âƒ£ Token versioning

Store:

users.jwt_version


JWT payload:

{ "ver": 3 }


On request:

Compare DB version

Reject old tokens

Again:
âŒ DB hit every request

Why Devise/session wins here
Feature	JWT	Devise
Logout	Weak	Strong
Immediate invalidation	âŒ	âœ…
Server control	âŒ	âœ…
Simplicity	âŒ	âœ…
Interview-ready explanation ğŸ¯

JWT is stateless, so the server does not track issued tokens. Logout only removes the token from the client, but the server will still accept it until it expires. This makes immediate logout and token revocation difficult without reintroducing server-side state.

One killer closing line ğŸ”¥

JWT trades logout control for scalability.

That line alone sounds very senior.