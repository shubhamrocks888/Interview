ğŸ§  First: the ONE mental rule (remember this)

Always create records from the parent association when possible

If you remember just this, youâ€™re 80% safe.

user.posts.create(...)
user.posts.build(...)


Why?
Rails auto-fills user_id, validations stay clean, fewer bugs.

ğŸ”¥ The 5 most common patterns (with WHEN to use)
1ï¸âƒ£ Parent exists â†’ create child (MOST COMMON)
user = User.find(params[:user_id])
post = user.posts.create(title: "Hello", status: "draft")


âœ… Auto assigns user_id
âœ… Clean
âœ… Interview-safe

Use this by default.

2ï¸âƒ£ Create parent + children together (on the fly)
Best way: accepts_nested_attributes_for
class User < ApplicationRecord
  has_many :posts
  accepts_nested_attributes_for :posts
end


Controller:

User.create!(
  email: "a@test.com",
  full_name: "A",
  posts_attributes: [
    { title: "Post 1", status: "draft" },
    { title: "Post 2", status: "published" }
  ]
)


âœ… Single call
âœ… Transaction-safe
âŒ Slightly more setup

Use when API accepts nested payloads.

3ï¸âƒ£ Explicit transaction (when logic is complex)
ActiveRecord::Base.transaction do
  user = User.create!(user_params)
  user.posts.create!(posts_params)
end


âœ… Guarantees consistency
âœ… Easy to explain in interviews

Use when:

Multiple models

External API calls

Conditional creation

4ï¸âƒ£ build vs create (super important)
post = user.posts.build(title: "Draft")
post.save


vs

user.posts.create(title: "Draft")

Method	Saves immediately?
build	âŒ No
create	âœ… Yes

ğŸ‘‰ Use build if you want to:

Add more fields later

Validate multiple objects first

5ï¸âƒ£ âŒ What NOT to do (common mistake)
Post.create(title: "X", user_id: user.id)


Why itâ€™s bad:

Easy to forget user_id

Bypasses association logic

Interviewers dislike this

ğŸš¦ Quick decision cheat-sheet (save this)
Parent exists?
 â”œâ”€ YES â†’ user.posts.create
 â””â”€ NO
     â”œâ”€ Simple â†’ accepts_nested_attributes_for
     â””â”€ Complex â†’ transaction

ğŸ§ª Real interview example answer (memorize this)

â€œI usually create associated records through the parent association
to avoid manually managing foreign keys.
For multi-record creation, I use transactions or nested attributes
to ensure atomicity.â€

That answer alone screams mid â†’ senior Rails dev.