ğŸ—‚ Architect-Level Background Jobs Cheat Sheet
1ï¸âƒ£ Basics of Background Jobs

Q: What are background jobs?
A: Tasks executed asynchronously outside the requestâ€“response cycle, used for long-running or non-critical work (emails, reports, 3rd-party calls).

Q: Why use background jobs?
A: Reduce request latency, isolate failures, improve UX.

Trap: â€œPush everything async?â€
Answer: No â€” async hides latency, doesnâ€™t remove bottlenecks. Critical operations may need synchronous guarantees.

2ï¸âƒ£ Reliability & Failures

Q: What happens if a job fails?
A: Sidekiq retries with exponential backoff, up to max attempts. Failed jobs exceeding retries go to Dead Letter Queue (DLQ).

Keywords to mention:

exponential backoff

jitter (randomized delay)

retry cap

dead-letter queue

alerting / monitoring

Architect nuance: Retries can break FIFO ordering. Must enforce idempotency.

3ï¸âƒ£ Idempotency

Definition: Running a job multiple times results in the same final state.

Implementation techniques:

Unique business key / idempotency key

DB constraints (UNIQUE, UPSERT)

State-based updates (update only if status = pending)

External API idempotency (pass key downstream)

Deduplication at enqueue time (optional)

One-liner:

â€œIdempotency ensures duplicate executions do not corrupt state using unique keys and DB constraints.â€

4ï¸âƒ£ Ordering / Dependencies

Q: How do you ensure job order?

FIFO per queue is guaranteed

Multiple queues â†’ no global order

Retry can break order

Solutions:

Job chaining / batches (Sidekiq Pro/Enterprise)

Sequence numbers / dependency table

Dedicated queue + single worker (strict sequential execution)

One-liner:

â€œDependent jobs should enqueue only after previous job succeeds; use batches or dedicated queues for strict order.â€

5ï¸âƒ£ Scaling & Traffic Control

Scenario: Downstream API allows 50 req/hour, traffic = 100/hr

Solutions:

| Approach           | Architect-approved solution                                      |
| ------------------ | ---------------------------------------------------------------- |
| Queue all requests | âŒ Infinite backlog â†’ starvation                                  |
| Delay jobs         | âŒ Jobs may never execute                                         |
| Rate limiting      | âœ… Bound system â†’ apply backpressure                              |
| Algorithms         | âœ… Leaky bucket â†’ constant rate<br>âœ… Token bucket â†’ allows bursts |


Keywords: backpressure, bounded queue, leaky bucket, token bucket, SLA, fair throttling

6ï¸âƒ£ Retry Storm Prevention

Problem: Many jobs fail at same time â†’ retries overwhelm system

Solution:

Exponential backoff

Jitter (randomized delay)

Retry caps / DLQ

Circuit breakers

Architect-level line:

â€œRetry storms are prevented with exponential backoff + jitter + circuit breakers, not fixed delays.â€

7ï¸âƒ£ Rate Limiting & Backpressure

Q: Why not just enqueue everything?

Answer: Unlimited input + limited output â†’ infinite backlog â†’ starvation.

Techniques:

Rate limit at ingress (before Sidekiq enqueue)

Bounded queues (e.g., max 100 jobs)

Reject / defer excess requests

Use leaky/token bucket for fairness

Optional AWS / infra note: Use autoscaling cautiously; scaling workers doesnâ€™t increase throughput if downstream is the bottleneck.

8ï¸âƒ£ Monitoring / Observability

Metrics to track:

Queue depth / latency

Job failure rate

Retry count

Downstream API usage / rate

SLA compliance

Tools: Sidekiq Web UI, Prometheus, Grafana, Sentry

9ï¸âƒ£ Security & Incident Handling

Scenario: Someone steals Razorpay key

Response:

Rotate credentials immediately

Block attacker (IP whitelisting)

Audit logs â†’ assess damage

Notify ops / finance / Razorpay

Apply least privilege keys, rate limits, secret management

One-liner:

â€œTreat stolen credentials as a security incident; contain, audit, rotate, and prevent recurrence.â€

10ï¸âƒ£ Architect Mindset Notes

Async â‰  scalable â€” always consider downstream limits

Retries â‰  idempotency â€” make jobs safe to rerun

FIFO â‰  global order â€” use sequences/batches for dependencies

Queue depth â‰  success â€” enforce backpressure / bounded queues

Security â€” always think blast radius, least privilege, detection

âœ… Cheat sheet for interviews

Magic sentences to impress architects:

â€œAsync hides latency, but backpressure is required to match output capacity.â€

â€œIdempotency is enforced via unique keys and database constraints, so retries are safe.â€

â€œRetry storms are prevented using exponential backoff with jitter and circuit breakers.â€

â€œLeaky bucket enforces constant throughput; token bucket allows bursts with average rate.â€

â€œDependent jobs enqueue only after prior job succeeds; for strict order, use batches or a dedicated queue.â€