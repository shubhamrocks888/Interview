Elixir Basics â€“ Variables, Functions, Syntax (Interview-Safe)
1ï¸âƒ£ Variables in Elixir (IMPORTANT DIFFERENCE)
Defining a variable
x = 10

Key rule (VERY IMPORTANT)

Variables are immutable

This works:

x = 10
x = x + 1


But whatâ€™s happening?

x is rebound, not mutated

Old value still exists conceptually

ğŸ”¥ Interview line:

Elixir allows rebinding but not mutation.

Rails comparison:

Ruby â†’ mutable variables

Elixir â†’ immutable values

2ï¸âƒ£ Data types (common ones)
number = 10
float  = 10.5
string = "hello"
atom   = :ok
boolean = true
list   = [1, 2, 3]
map    = %{name: "John", age: 30}
tuple  = {:ok, "success"}

Atoms (VERY IMPORTANT)

Constants

Often used as status values

Rails equivalent:

Symbols (:ok in Ruby)

3ï¸âƒ£ Pattern Matching (CORE CONCEPT)
{:ok, result} = {:ok, 200}


Works âœ”ï¸

{:ok, result} = {:error, "failed"}


Crashes âŒ

ğŸ”¥ Interview line:

Assignment in Elixir is pattern matching, not variable assignment.

4ï¸âƒ£ Functions in Elixir
Anonymous function
add = fn a, b -> a + b end
add.(2, 3)


Note the dot . when calling.

Named function (most common)
defmodule Math do
  def add(a, b) do
    a + b
  end
end


Call it:

Math.add(2, 3)


Rails comparison:

Module â‰ˆ class (kind of)

Functions â‰  methods with state

5ï¸âƒ£ Function pattern matching (VERY IMPRESSIVE)
defmodule Greeter do
  def greet(:admin), do: "Hello Admin"
  def greet(:user),  do: "Hello User"
end


Elixir chooses the correct function automatically.

ğŸ”¥ Interview line:

Elixir uses function heads for pattern matching instead of conditionals.

6ï¸âƒ£ Default arguments
def greet(name \\ "Guest") do
  "Hello #{name}"
end

7ï¸âƒ£ Conditionals (rarely used heavily)
if
if age >= 18 do
  "Adult"
else
  "Minor"
end

Prefer case
case result do
  {:ok, _} -> "Success"
  {:error, _} -> "Failure"
end

8ï¸âƒ£ Lists and Enum (functional style)
Enum.map([1, 2, 3], fn x -> x * 2 end)


Shortcut:

Enum.map([1, 2, 3], &(&1 * 2))


ğŸ”¥ Interview line:

Elixir prefers data transformations using Enum over loops.

9ï¸âƒ£ Pipe operator (|>) â€“ VERY IMPORTANT
[1, 2, 3]
|> Enum.map(&(&1 * 2))
|> Enum.filter(&(&1 > 3))


Reads like:

Take list â†’ map â†’ filter

Rails analogy:

Method chaining

ğŸ”Ÿ Guards (bonus, but nice)
def adult?(age) when age >= 18 do
  true
end

1ï¸âƒ£1ï¸âƒ£ What NOT to say in interview

âŒ â€œElixir has variables like Rubyâ€
âŒ â€œElixir is object-orientedâ€

Instead:

Elixir is functional, immutable, and relies heavily on pattern matching.

ğŸ”‘ 60-second summary (MEMORIZE)

Variables in Elixir are immutable and use pattern matching. Functions are defined inside modules, support multiple clauses, and data is transformed using Enum and the pipe operator.