In Elixir:

A process is a lightweight unit of execution managed by the BEAM VM.
Costs a few KBs of memory
Creation is cheap
Millions can exist at once
Each has isolated state


What â€œ1 process per connectionâ€ means
In Elixir / Phoenix:

When a user connects (HTTP request, WebSocket, LiveView, Kafka message):

ğŸ‘‰ Elixir spawns a new lightweight process
ğŸ‘‰ That process:

Handles that userâ€™s request
Maintains only that userâ€™s state
Dies when work is done
No shared objects. 
No locks.

ğŸ”¹ Compare with Ruby (Rails)
Rails

Limited thread pool (e.g., 5â€“16 threads)
One thread handles many requests over time
Requests wait in a queue if threads are busy
Threads share memory â†’ locks

Elixir

Every request gets its own process
Requests donâ€™t block each other
Scheduler switches between processes efficiently

ğŸ”¹ Visual Mental Model (IMPORTANT)
Ruby
Request Queue â†’ Thread Pool (10 threads) â†’ App


100,000 users â†’ most wait

Elixir
100,000 connections â†’ 100,000 lightweight processes


Scheduler distributes them across CPU cores.

ğŸ”¹ Example (Conceptual)
spawn(fn ->
  handle_request(conn)
end)


Every request â†’ new process

ğŸ’¡ You donâ€™t write this manually in Phoenix â€” the framework does it for you.

ğŸ”¹ Why this scales
Because:

No shared memory
No mutexes
No thread exhaustion
Processes are isolated

Golden line:

â€œIn Elixir, a spike in traffic creates more processes, not contention.â€

ğŸ”¹ What happens if one user crashes?
Elixir

Only that userâ€™s process crashes
Supervisor restarts it
Others unaffected

Ruby

Exception may kill thread
Can impact shared state
Requires defensive coding

ğŸ”¹ WebSockets / LiveView Example (Very Strong Point)

WebSockets keep connections open.

Ruby

Threads stay busy
Memory pressure
Hard limit on connections

Elixir

Idle process consumes almost no CPU
Can hold hundreds of thousands of open connections

Say this:

â€œElixir is ideal for long-lived connections because idle processes are cheap.â€

ğŸ”¹ Final Interview-Perfect Explanation (Memorize)

â€œ1 process per connection means that each user request or connection is handled by its own lightweight Elixir process.
These processes are cheap, isolated, and scheduled by the BEAM VM, which allows the system to handle massive concurrency without thread contention or shared state issues.â€

ğŸ”¥ If interviewer asks â€œIsnâ€™t that expensive?â€

Answer:

â€œNo. Elixir processes are extremely lightweightâ€”on the order of kilobytesâ€”and are much cheaper than OS threads.â€

