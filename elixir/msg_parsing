How processes interact via message passing in BEAM
Interview-ready definition (say this first)

In BEAM, processes communicate by sending asynchronous messages to each otherâ€™s mailboxes. Each process has its own isolated memory and processes messages sequentially from its inbox.

1ï¸âƒ£ Every process has a mailbox

When a BEAM process is created:

It gets its own mailbox (message queue)

No other process can access its memory

Think of it like:

Each process = independent worker

Mailbox = private queue

2ï¸âƒ£ Sending a message (send/2)

Syntax:

send(pid, message)


Example:

send(pid, {:process_order, order_id})


What happens:

Message is copied

Placed in the receiverâ€™s mailbox

Sender continues immediately (non-blocking)

ğŸ”¥ Interview line:

Message passing in BEAM is asynchronous and non-blocking.

3ï¸âƒ£ Receiving a message (receive)

A process handles messages using receive:

receive do
  {:process_order, order_id} ->
    process(order_id)

  {:cancel_order, order_id} ->
    cancel(order_id)
end


Important points:

Messages are pattern-matched

Process handles one message at a time

Order is FIFO (with pattern matching priority)

ğŸ”¥ Interview line:

Processes consume messages sequentially, which eliminates race conditions.

4ï¸âƒ£ Pattern matching (VERY important)

Elixir does not just read messages blindly.

It matches based on structure:

{:ok, result}
{:error, reason}


This makes code:

Explicit

Safe

Easy to reason about

Rails comparison:

Instead of checking params manually

Elixir pattern-matches upfront

5ï¸âƒ£ Synchronous vs Asynchronous messaging
ğŸ”¹ Asynchronous (fire-and-forget)
send(pid, {:event, data})


No reply expected

Like pushing a job to Sidekiq

ğŸ”¹ Synchronous (requestâ€“response)

Usually via GenServer.call:

GenServer.call(pid, {:get_state})


Under the hood:

Sends a message

Waits for reply

ğŸ”¥ Interview line:

GenServer abstracts message passing by providing synchronous and asynchronous APIs.

6ï¸âƒ£ GenServer (REAL-world usage)

In production, you rarely use raw send/receive.

You use GenServer:

GenServer.cast(pid, {:increment, 1})   # async
GenServer.call(pid, :get_count)         # sync


Internally:

Messages go to mailbox

GenServer processes them one by one

Rails analogy:

GenServer â‰ˆ Sidekiq worker + state + mutex-free safety

7ï¸âƒ£ Why this model is powerful
âœ… No shared memory

No locks

No mutexes

No race conditions

âœ… Fault isolation

If one process crashes â†’ others continue

âœ… Scalability

Millions of processes possible

ğŸ”¥ Interview line:

Message passing allows BEAM to scale safely without shared mutable state.

8ï¸âƒ£ Example in real system (Kafka consumer)

You can say:

In a Kafka-based system, each partition consumer can be modeled as a GenServer. Messages from Kafka are sent to the GenServer mailbox, processed sequentially, and failures are handled by supervisors.

This ties directly to their JD ğŸ”¥

9ï¸âƒ£ Comparison with Rails (VERY INTERVIEW-FRIENDLY)

| Rails           | Elixir                |
| --------------- | --------------------- |
| Shared memory   | Isolated processes    |
| Locks needed    | No locks              |
| Sidekiq retries | Supervisor restarts   |
| Threads         | Lightweight processes |

1ï¸âƒ£0ï¸âƒ£ One-liner summary (MEMORIZE)

Processes in BEAM interact by sending immutable messages to each otherâ€™s mailboxes, where messages are processed sequentially using pattern matching.

If interviewer pushes deeper
â“ â€œWhat happens if a process crashes while processing a message?â€

Answer:

The process crashes, the message is lost, and the supervisor restarts the process. The system remains stable.