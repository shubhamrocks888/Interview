Weâ€™ll do this slowly, one step at a time, exactly how an interviewer expects a senior to understand GenServer â€” not memorize it.

We will not jump ahead.

STEP 0 â€” Why GenServer exists (1-minute clarity)

Before syntax, understand WHY.

You already know this:

send(pid, msg)
receive do
  msg -> ...
end


Problems:

No structure

Hard to manage state

No restart if process crashes

Every developer writes their own loop

ðŸ’¡ GenServer = a standardized process loop

GenServer is a behaviour that wraps send/receive into a clean, safe, reusable abstraction.

STEP 1 â€” What a GenServer actually is

A GenServer is:

âœ… One process
âœ… With its own mailbox
âœ… With internal state
âœ… That reacts to messages via callbacks

ðŸ’¬ Interview sentence:

â€œA GenServer is a long-running process that encapsulates state and handles messages in a structured way.â€

STEP 2 â€” Minimal GenServer skeleton (just syntax)

Donâ€™t think logic yet. Just structure.

defmodule MyServer do
  use GenServer
end


Thatâ€™s it.
Nothing else yet.

What use GenServer does

Tells Elixir: this module follows the GenServer behaviour

Expects certain callbacks (init, handle_call, handle_cast)

STEP 3 â€” Starting a GenServer (VERY IMPORTANT)

A GenServer does nothing until it is started.

Basic start
GenServer.start_link(MyServer, initial_state)


Example:

GenServer.start_link(MyServer, %{})


This:

Starts a new process

Calls init/1

Returns {:ok, pid}

STEP 4 â€” init/1 callback (first real code)

Every GenServer must have init/1.

defmodule MyServer do
  use GenServer

  def init(state) do
    {:ok, state}
  end
end

What happens:

Process starts

init(state) is called

Returned state becomes process memory

ðŸ’¡ State lives inside the process, not shared.

STEP 5 â€” Clean client/server separation (BEST PRACTICE)

This is important for interviews.

defmodule MyServer do
  use GenServer

  ## CLIENT API
  def start_link(initial_state) do
    GenServer.start_link(__MODULE__, initial_state)
  end

  ## SERVER CALLBACK
  def init(state) do
    {:ok, state}
  end
end


Why?

Other modules should not call GenServer.call directly

Encapsulation

ðŸ”¥ Interview line:

â€œWe expose a client API and keep GenServer callbacks private.â€

STEP 6 â€” Talking to GenServer (NO LOGIC YET)

Two ways (you already know conceptually):

Async â€” cast
GenServer.cast(pid, :ping)

Sync â€” call
GenServer.call(pid, :ping)


âš ï¸ Donâ€™t handle them yet. Just know the syntax.

STEP 7 â€” handle_cast (async messages)
def handle_cast(:ping, state) do
  IO.puts("Received ping")
  {:noreply, state}
end


Meaning:

Message arrives

State remains unchanged

No reply sent

ðŸ’¬ Interview:

â€œhandle_cast handles fire-and-forget messages.â€

STEP 8 â€” handle_call (sync messages)
def handle_call(:ping, _from, state) do
  {:reply, :pong, state}
end


Meaning:

Caller waits

Reply is returned

State preserved

STEP 9 â€” Full minimal working GenServer
defmodule MyServer do
  use GenServer

  ## Client
  def start_link(state) do
    GenServer.start_link(__MODULE__, state)
  end

  def ping(pid) do
    GenServer.call(pid, :ping)
  end

  ## Server
  def init(state), do: {:ok, state}

  def handle_call(:ping, _from, state) do
    {:reply, :pong, state}
  end
end


Run:

{:ok, pid} = MyServer.start_link(%{})
MyServer.ping(pid)
# => :pong

STEP 10 â€” Map this to what you already know

| You learned earlier | GenServer          |
| ------------------- | ------------------ |
| spawn               | start_link         |
| send                | cast / call        |
| receive             | handle_* callbacks |
| mailbox             | GenServer mailbox  |
| state variable      | GenServer state    |


ðŸ”¥ This mapping is interview gold.