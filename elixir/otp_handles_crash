How OTP handles â€œLet it crashâ€
Interview-ready definition (say this first)

OTP follows a â€œlet it crashâ€ philosophy where individual processes are allowed to fail, and supervisors automatically detect the failure and restart them, keeping the system running.

1ï¸âƒ£ What â€œlet it crashâ€ actually means (clear the myth)

âŒ It does NOT mean:

Ignore errors

Write buggy code

Crash the whole app

âœ… It means:

Donâ€™t defensively handle every possible error

Let a process fail fast

Recover using supervision

2ï¸âƒ£ Core OTP building blocks

OTP handles â€œlet it crashâ€ using three layers:

ğŸ”¹ 1. Worker processes

GenServer

Task

Kafka consumer

Background worker

These do the work and may crash.

ğŸ”¹ 2. Supervisors

Monitor worker processes

Restart them on failure

Example:

Supervisor.start_link(children, strategy: :one_for_one)


ğŸ”¥ Interview line:

Supervisors observe child processes and apply restart strategies when failures occur.

ğŸ”¹ 3. Supervision trees

Supervisors can supervise other supervisors

Forms a hierarchy

This ensures:

Local failures stay local

System remains stable

3ï¸âƒ£ What happens when a process crashes (STEP BY STEP)

Letâ€™s say a GenServer crashes:

Process encounters an error

Process exits

Supervisor receives exit signal

Supervisor applies restart strategy

Process restarts with clean state

ğŸ”¥ Key point:

The failed process is restarted in isolation without impacting other processes.

4ï¸âƒ£ Supervisor strategies (INTERVIEW FAVORITE)
ğŸ”¹ :one_for_one

Restart only the failed process
ğŸ‘‰ Most common

ğŸ”¹ :one_for_all

Restart all child processes
ğŸ‘‰ Use when processes depend on each other

ğŸ”¹ :rest_for_one

Restart the failed process and those started after it

ğŸ”¥ Interview line:

Supervisor strategies allow us to model dependency relationships between processes.

5ï¸âƒ£ Why OTP doesnâ€™t use try/catch everywhere

In Rails:

Rescue exceptions everywhere

Retry logic in app code

In OTP:

Crashes are signals

Recovery is centralized

ğŸ”¥ Interview line:

OTP treats failures as expected events and handles recovery declaratively via supervisors.

6ï¸âƒ£ Message passing + let it crash

Important detail:

Messages sent to a crashed process:

Are lost

Restarted process:

Starts fresh

Does not resume old mailbox

This avoids:

Corrupted state

Half-processed data

7ï¸âƒ£ Real-world example (Kafka consumer â€“ USE THIS)

Each Kafka partition consumer can run as a GenServer under a supervisor. If message processing fails, the consumer crashes, the supervisor restarts it, and the system continues processing without affecting other partitions.

ğŸ”¥ This directly matches their JD.

8ï¸âƒ£ Comparison with Rails (VERY INTERVIEW FRIENDLY)
Rails	OTP
Rescue everywhere	Let process crash
Sidekiq retries	Supervisor restarts
App restarts	Process restarts
Shared failure	Isolated failure
9ï¸âƒ£ When NOT to let it crash

Important senior insight:

Business errors should be handled explicitly, while unexpected system errors should crash the process.

Example:

âŒ Invalid input â†’ handle

âŒ DB unavailable â†’ crash & restart

ğŸ”Ÿ One-liner summary (MEMORIZE THIS)

OTP embraces failure by isolating processes and using supervisors to automatically restart failed components, keeping the system resilient.

Final confidence booster ğŸ’ª