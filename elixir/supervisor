Supervisor is the missing piece that makes everything you learned production-ready.

Weâ€™ll go slow, structured, one step at a time. No jumping.

STEP 1 â€” Why Supervisor exists (core idea)

Right now you have this:

A GenServer running

It sends emails

It holds state

âŒ Problem:

If the GenServer crashes, your system is dead.

Elixirâ€™s answer is NOT:

try/catch everywhere

rescue blocks

defensive programming

Elixirâ€™s answer is:

Let it crash â€” and restart it automatically

Thatâ€™s exactly what a Supervisor does.

STEP 2 â€” What a Supervisor is (plain English)

A Supervisor is:

A process whose only job is to start, stop, and restart other processes.

It does not do business logic.

STEP 3 â€” Supervisor mental model (very important)
Supervisor
   |
   +â”€â”€ MyServer (GenServer)


If MyServer crashes:

Supervisor notices

Restarts it based on rules

ğŸ”¥ Interview line:

â€œSupervisors provide fault tolerance by monitoring child processes and restarting them when they fail.â€

STEP 4 â€” Minimal Supervisor syntax (just structure)
defmodule MySupervisor do
  use Supervisor
end


Nothing else yet.

STEP 5 â€” Starting a Supervisor

Supervisor also needs to be started.

Supervisor.start_link(children, strategy: :one_for_one)


But we usually wrap it in a module.

STEP 6 â€” Define children (VERY IMPORTANT)

Children are the processes the supervisor manages.

children = [
  MyServer
]


This works only if MyServer.start_link/1 exists.

STEP 7 â€” Complete minimal Supervisor
defmodule MySupervisor do
  use Supervisor

  def start_link(_) do
    Supervisor.start_link(__MODULE__, :ok)
  end

  def init(:ok) do
    children = [
      MyServer
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end


Meaning:

Start MyServer

If it crashes â†’ restart only that one

STEP 8 â€” Connect GenServer to Supervisor

Your GenServer must have this:

def start_link(_) do
  GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
end


Supervisor will call this automatically.

STEP 9 â€” Test â€œlet it crashâ€

Add this inside handle_cast:

def handle_cast({:send_email, "crash"}, state) do
  raise "Boom!"
end


Now run:

MyServer.send_email("crash")


What happens:

GenServer crashes

Supervisor restarts it

System keeps running

ğŸ”¥ THIS is â€œlet it crashâ€.

STEP 10 â€” Restart strategies (interview MUST-KNOW)
Strategy	Meaning
:one_for_one	Restart only the crashed child
:one_for_all	Restart all children
:rest_for_one	Restart crashed + those started after it

Most common:
âœ… :one_for_one

STEP 11 â€” Application module (real apps)

In real apps, supervisors are started automatically.

defmodule MyApp.Application do
  use Application

  def start(_type, _args) do
    children = [
      MySupervisor
    ]

    Supervisor.start_link(children, strategy: :one_for_one)
  end
end


This is the root supervisor.

STEP 12 â€” Rails analogy (helps a LOT)
Rails	Elixir
Sidekiq retries	Supervisor restarts
Rescue + retry	Let it crash
Systemd / PM2	BEAM supervision tree
STEP 13 â€” Interview-ready summary (memorize)

Say this confidently:

â€œSupervisors monitor GenServers and restart them on failure. Instead of defensive coding, Elixir uses supervision trees to achieve fault tolerance, following the let-it-crash philosophy.â€

STOP HERE ğŸ›‘

You now understand:

Why supervisors exist

How they restart GenServers

How they fit into production systems