Q1ï¸âƒ£ What does this return?
	User.select(:email).first


	Answer:

	#<User id: nil, email: "a@test.com">


	ğŸ’¥ Trap

	id is nil

	Calling user.save â†’ âŒ ERROR

	Partial object, not safe to persist

	ğŸ“Œ Interview line:

	select creates partial ActiveRecord objects.


Q4ï¸âƒ£ Will this hit the DB once or twice?
	relation = User.select(:email)
	relation.pluck(:email)


	âŒ Twice

	Why?

	pluck ignores previous select

	Fires its own SQL

Q5ï¸âƒ£ Output?
	User.where(active: false).pluck(:id).count


	âŒ BAD
	Loads all IDs into memory.

	âœ… Better:

	User.where(active: false).count


	ğŸ“Œ Interview rule:

	If DB can count, let DB count.


âŒ Mistake 2: Using select in background jobs

	User.select(:id).each do |user|
	  process(user)
	end


	Still creates objects â†’ memory waste.

	âœ… Better:

	User.ids.each do |id|
	  process(id)
	end
