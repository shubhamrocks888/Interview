Core difference

pluck:

	Runs direct SQL.
	Returns raw Ruby values (Array).
	Does NOT instantiate ActiveRecord objects

	Lowest memory usage

		User.pluck(:id, :email)
		# => [[1, "a@test.com"], [2, "b@test.com"]]

select:


	Builds ActiveRecord objects.
	Still hits DB, but instantiates models.
	Heavier in memory & slower

	User.select(:id, :email)
	# => [#<User id: 1, email: "...">, ...]

######
Performance comparison (important)

| Case                  | Faster     | Reason                     |
| --------------------- | ---------- | -------------------------- |
| Fetch only values     | ‚úÖ `pluck`  | No object creation         |
| Large datasets        | ‚úÖ `pluck`  | Low memory                 |
| Need model methods    | ‚ùå `select` | `pluck` can‚Äôt call methods |
| Chaining scopes later | ‚ùå `pluck`  | `pluck` ends the relation  |


#####
Under the hood (interview gold ‚≠ê)
	pluck
	SELECT id, email FROM users;


	‚û° Ruby receives Array, done.

	select
	SELECT id, email FROM users;


	‚û° Rails wraps each row into a User object

	Object creation = slower + more memory.


####
Benchmarked intuition:

	For 100k records:

	User.pluck(:id)
	# ~ 0.2s

	User.select(:id).map(&:id)
	# ~ 1.2s (object creation cost)


######
	Very common trap ‚ö†Ô∏è
	User.select(:email).pluck(:email)


	‚ùå WRONG assumption
	pluck ignores select and fires new SQL

	SELECT email FROM users;

Rule of thumb ‚úÖ

	Need raw data? ‚Üí pluck

	Need AR objects or methods? ‚Üí select

	Huge dataset? ‚Üí pluck

	Rendering views? ‚Üí select

	One-line interview answer üéØ

	"pluck is faster than select because it avoids ActiveRecord object instantiation and returns raw values directly from SQL."



	##############

	Interview one-liner ‚≠ê

An ActiveRecord::Relation is a lazy collection that contains fully-fledged model objects, but only with the columns explicitly selected.

#####

FINAL ONE-LINER (memorize this)

"pluck is SQL-level data fetching, select is ORM-level object creation."