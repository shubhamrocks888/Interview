ğŸ”¥ What Are Callbacks?

Callbacks are methods that automatically run at certain points in an ActiveRecord objectâ€™s lifecycle.

For example:

Before saving

After saving

Before destroying

After committing to DB

They are defined inside your model.

ğŸ“Œ 1ï¸âƒ£ before_validation
ğŸ‘‰ Runs before validations
âœ… Use case:

Normalize or clean data before validation.

before_validation :normalize_email

def normalize_email
  self.email = email.strip.downcase if email.present?
end


âœ” Ensures email format is consistent
âœ” Runs before valid?

ğŸ“Œ 2ï¸âƒ£ after_validation
ğŸ‘‰ Runs after validations
âœ… Use case:

Log validation results or modify errors.

after_validation :log_validation_errors

def log_validation_errors
  Rails.logger.info(errors.full_messages) if errors.any?
end


Rarely used.

ğŸ“Œ 3ï¸âƒ£ before_save
ğŸ‘‰ Runs before create & update
âœ… Use case:

Set derived attributes.

before_save :calculate_total

def calculate_total
  self.total_price = quantity * price
end


âš  Runs on both create and update.

ğŸ“Œ 4ï¸âƒ£ before_create
ğŸ‘‰ Runs only when record is first created
âœ… Use case:

Generate tokens

before_create :generate_referral_code

def generate_referral_code
  self.referral_code = SecureRandom.hex(6)
end


Perfect for:

API keys

UUIDs

Default values

ğŸ“Œ 5ï¸âƒ£ after_create
ğŸ‘‰ Runs after record is created
âœ… Use case:

Send welcome email

after_create :send_welcome_email

def send_welcome_email
  UserMailer.welcome(self).deliver_later
end


âš  But better practice â†’ use after_commit instead.

ğŸ“Œ 6ï¸âƒ£ before_update
ğŸ‘‰ Runs only when updating existing record

Example:

before_update :prevent_status_change_if_locked

def prevent_status_change_if_locked
  if locked? && saved_change_to_status?
    errors.add(:status, "cannot change when locked")
    throw(:abort)
  end
end

ğŸ“Œ 7ï¸âƒ£ after_update

Example:

after_update :notify_status_change, if: :saved_change_to_status?

def notify_status_change
  NotificationService.notify(self)
end

ğŸ“Œ 8ï¸âƒ£ after_save

Runs after create + update.

âš  Still inside transaction.

Not safe for external services.

ğŸ“Œ 9ï¸âƒ£ after_commit â­ (MOST IMPORTANT)
ğŸ‘‰ Runs after DB transaction is committed
âœ… Best for:

Sending emails

Enqueuing jobs

Calling external APIs

after_commit :send_completion_email,
             if: -> { saved_change_to_status? && completed? }

def send_completion_email
  RideMailer.completed(self).deliver_later
end


Why after_commit?

Because if transaction fails, email won't send.

ğŸ”¥ This is production-grade practice.

ğŸ“Œ ğŸ”Ÿ before_destroy
ğŸ‘‰ Runs before record deletion

Example:

before_destroy :check_if_paid_orders_exist

def check_if_paid_orders_exist
  if orders.paid.exists?
    errors.add(:base, "Cannot delete user with paid orders")
    throw(:abort)
  end
end

ğŸ“Œ 1ï¸âƒ£1ï¸âƒ£ after_destroy

Example:

after_destroy :log_deletion

def log_deletion
  Rails.logger.info("User #{id} deleted")
end

ğŸ“Œ 1ï¸âƒ£2ï¸âƒ£ after_initialize

Runs when object is instantiated.

after_initialize :set_defaults

def set_defaults
  self.status ||= "requested"
end


Rarely needed.

ğŸ§  Callback Order (Important for Interviews)

Create flow:

before_validation
after_validation
before_save
before_create
after_create
after_save
after_commit

ğŸš¨ When NOT to Use Callbacks

Senior-level advice ğŸ‘‡

âŒ Donâ€™t put business logic
âŒ Donâ€™t put complex workflows
âŒ Donâ€™t trigger multiple dependent side effects

Instead use:

Service Objects

Command Objects

Interactors

ğŸ’¡ Good Use Cases

âœ” Data normalization
âœ” Auto-setting fields
âœ” Logging
âœ” Simple notifications
âœ” Background job enqueue

âŒ Bad Use Cases

âŒ Payment processing
âŒ Complex workflow state machines
âŒ Multi-model operations

ğŸ¯ Clean Production Example
class Ride < ApplicationRecord
  enum status: { requested: 0, started: 1, completed: 2 }

  after_commit :send_completion_email, if: :just_completed?

  private

  def just_completed?
    saved_change_to_status? && completed?
  end

  def send_completion_email
    RideMailer.completed(self).deliver_later
  end
end


âœ” Clean
âœ” Safe
âœ” Transaction-safe
âœ” Readable