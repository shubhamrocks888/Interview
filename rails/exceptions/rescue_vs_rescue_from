rescue vs rescue_from (Rails)
ğŸ”¹ 1ï¸âƒ£ rescue (Ruby-level)
What it is

Plain Ruby exception handling

Works anywhere: models, services, controllers, jobs

begin
  do_something
rescue Payment::Failed => e
  Rails.logger.error(e.message)
end


OR shorthand:

def call
  do_something
rescue Payment::Failed => e
  handle_error(e)
end

âœ… Use when

Handling local, specific logic

Inside service objects

Inside background jobs

You want fine-grained control

âŒ Donâ€™t use when

You want global request-level handling

You donâ€™t want to swallow bugs

ğŸ¯ Interview line:

â€œrescue is Ruby-level and scoped to a block or method.â€

ğŸ”¹ 2ï¸âƒ£ rescue_from (Rails-level)
What it is

Rails controller feature

Handles exceptions globally across requests

Defined in ApplicationController

class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :not_found

  def not_found
    render json: { error: "Not Found" }, status: :not_found
  end
end

âœ… Use when

Handling expected application errors

Rendering consistent HTTP responses

API error handling

âŒ Limitations

Works only in controllers

Not available in models/services/jobs

ğŸ¯ Interview line:

â€œrescue_from is Rails-specific and controller-scoped.â€

ğŸ§  KEY DIFFERENCES (Interview Table)

| Aspect        | `rescue`       | `rescue_from`        |
| ------------- | -------------- | -------------------- |
| Level         | Ruby           | Rails                |
| Scope         | Block / Method | Controller / App     |
| Where         | Anywhere       | Controllers only     |
| Best for      | Business logic | Request-level errors |
| Granularity   | Fine           | Global               |
| API responses | âŒ manual       | âœ… clean & consistent |


ğŸ¯ Example Interview Scenario
â“ Question

â€œHow would you handle ActiveRecord::RecordNotFound?â€

âŒ Weak answer

â€œIâ€™ll rescue it in every controller action.â€

âœ… Strong answer

â€œI handle it once using rescue_from in ApplicationController.â€

rescue_from ActiveRecord::RecordNotFound do
  render json: { error: "Record not found" }, status: :not_found
end

ğŸ”¥ Combined Usage (BEST PRACTICE)
Service Object
class Orders::CreateOrder
  def call
    Order.create!
  rescue ActiveRecord::RecordInvalid => e
    Rails.logger.error(e.message)
    raise
  end
end

Controller
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordInvalid do |e|
    render json: { error: e.record.errors }, status: :unprocessable_entity
  end
end


ğŸ¯ Interview line:

â€œI rescue locally where it makes sense and handle response formatting globally.â€

ğŸš« Common Interview Red Flags
rescue
end


âŒ Swallows everything
âŒ Hides bugs
âŒ Production nightmare

ğŸ¯ Say:

â€œI never rescue StandardError blindly.â€

ğŸ PERFECT INTERVIEW ANSWER (30 sec)

â€œrescue is Ruby-level and used for local error handling inside services or jobs. rescue_from is Rails-specific and used in controllers to handle expected exceptions globally and return consistent HTTP responses. I use both depending on the scope.â€