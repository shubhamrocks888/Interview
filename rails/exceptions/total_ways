1ï¸âƒ£ What interviewers actually mean

When they ask:

â€œHow do you handle exceptions in Rails?â€

Theyâ€™re checking if you understand:

Where exceptions should be handled

Which ones should be rescued

How to avoid hiding bugs

How to report errors (Sentry, logs)

User-friendly error responses

2ï¸âƒ£ Ways to handle exceptions in Rails (from BEST â†’ WORST)
âœ… 1. Global exception handling (Recommended)
ApplicationController
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
  rescue_from ActiveRecord::RecordInvalid, with: :record_invalid

  def record_not_found
    render json: { error: "Record not found" }, status: :not_found
  end

  def record_invalid(exception)
    render json: { error: exception.record.errors.full_messages },
           status: :unprocessable_entity
  end
end


ğŸ¯ Interview line:

â€œI use rescue_from for expected application-level exceptions.â€

âœ… 2. Service Object level handling
class Orders::CreateOrder
  def call
    Order.transaction do
      # logic
    end
  rescue ActiveRecord::RecordInvalid => e
    Rails.logger.error(e.message)
    raise
  end
end


ğŸ¯ Key point:

Log

Re-raise

Donâ€™t silently swallow errors

âœ… 3. Controller-level rescue (sparingly)
def create
  service.call
rescue Payment::Failed => e
  render json: { error: e.message }, status: :payment_required
end


ğŸ¯ Use only for request-specific handling.

âš ï¸ 4. Background job exception handling
class PaymentJob < ApplicationJob
  retry_on Payment::Timeout, wait: 5.seconds, attempts: 3
  discard_on ActiveRecord::RecordNotFound

  def perform(order_id)
    Payment.charge!(order_id)
  end
end


ğŸ¯ Interview bonus points:

â€œI use retry_on and discard_on in ActiveJob.â€

âŒ 5. Bad practice (interview red flag)
begin
  do_something
rescue
end

Why itâ€™s bad

Swallows bugs

Makes debugging impossible

ğŸ¯ Interview line:

â€œI never rescue StandardError blindly.â€

3ï¸âƒ£ How Rails handles exceptions internally

Unhandled exceptions â†’ bubble up

In development â†’ full stack trace

In production â†’ 500 error page

Can be overridden using:

config.exceptions_app

4ï¸âƒ£ Custom error pages (advanced)
# config/application.rb
config.exceptions_app = self.routes

get "/404", to: "errors#not_found"
get "/500", to: "errors#internal_error"


ğŸ¯ Senior-level answer.

5ï¸âƒ£ Logging & Monitoring (VERY IMPORTANT)
Interviewers expect this mention:
Rails.logger.error(e.message)
Sentry.capture_exception(e)


Tools:

Sentry

Bugsnag

Honeybadger

ğŸ¯ Interview line:

â€œI log and report exceptions instead of silently rescuing.â€

6ï¸âƒ£ When NOT to handle exceptions

âŒ Donâ€™t rescue:

NoMethodError

NameError

Programmer bugs

ğŸ¯ Interview line:

â€œUnexpected exceptions should crash loudly.â€

7ï¸âƒ£ PERFECT INTERVIEW ANSWER (Say this)

â€œIn Rails, I handle expected exceptions using rescue_from at the controller level, use service objects to encapsulate business logic, and avoid rescuing generic exceptions. I log and report errors using tools like Sentry, and for background jobs I rely on retry mechanisms. Unexpected errors are allowed to bubble up.â€