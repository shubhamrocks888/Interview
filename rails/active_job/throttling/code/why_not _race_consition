count = Rails.cache.read(key)

if count <= limit
  Rails.cache.increment(key)
  allow = true
else
  allow = false
end


State

limit = 5

initial count = 4

â± Timeline (real concurrency)
T1: Request A reads count = 4
T2: Request B reads count = 4

T3: Request A checks 4 <= 5 â†’ true
T4: Request B checks 4 <= 5 â†’ true

T5: Request A increments â†’ count = 5
T6: Request B increments â†’ count = 6

Result

âœ… Request A allowed

âŒ Request B also allowed

But only one slot was actually available (the 5th)

Thatâ€™s the bug.

ğŸ§  Why your â€œstill one passesâ€ intuition feels right (but isnâ€™t)

Youâ€™re subconsciously assuming:

The second request will see the updated count

But it doesnâ€™t â€” because it already:

read the old value

evaluated the condition

committed to allowing

Concurrency breaks that assumption.

âœ… Why the atomic version works
current = Rails.cache.increment(key)
current <= limit


Now the timeline is:

Request A â†’ INCR â†’ returns 5 â†’ allowed
Request B â†’ INCR â†’ returns 6 â†’ blocked


Only one request gets <= limit.

âœ” Decision and mutation are tied together.

ğŸ Interview-quality conclusion

Even though increment is atomic, doing a separate read first causes both requests to pass the check using stale data. Only when the increment itself determines the decision do we avoid the race condition.

If you want, I can: