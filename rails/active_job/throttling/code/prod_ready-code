class Throttler
  def initialize(limit:, period:)
    @limit = limit
    @period = period
  end

  def allow?(key)
    current = Rails.cache.increment(
      cache_key(key),
      1,
      initial: 0,
      expires_in: @period
    )

    current <= @limit
  end

  private

  def cache_key(key)
    "throttler:#{key}"
  end
end


#############


ouâ€™re right about one thing:

Rails.cache.increment by itself is atomic.

But the race condition is not inside increment.
It happens between the read and the increment.

ðŸ” Two different flows (this is the whole confusion)
âœ… Safe flow (what you have now)
current = Rails.cache.increment(key)
current <= limit


ONE operation

No prior read

Redis does it atomically

âœ” No race condition

âŒ Unsafe flow (read â†’ then increment)
count = Rails.cache.read(key)

if count < limit
  current = Rails.cache.increment(key)
  allow = true
else
  allow = false
end


Hereâ€™s the issue ðŸ‘‡

ðŸ§¨ Where the race happens (step-by-step)

Assume:

limit = 5

key = 4

Timeline
Request A â†’ read = 4
Request B â†’ read = 4   (same time)

Request A â†’ increment â†’ 5
Request B â†’ increment â†’ 6


Both requests passed the if count < limit check
ðŸ‘‰ You allowed 2 requests, but only 1 should be allowed.

Yes, increment itself is atomic â€”
but the decision to call it was based on stale data.

ðŸ§  Key insight (this clicks once)

Atomic operations donâ€™t help if your decision logic is outside the atomic boundary.

You need:

check + increment


to be atomic together.

Your current solution does that by:

always incrementing

deciding based on the returned value

âš–ï¸ Why this design is intentional

â€œBut weâ€™re incrementing even when blocked!â€

Correct â€” and thatâ€™s fine because:

Once limit is crossed, all requests are blocked anyway

TTL will reset the counter

Exact number beyond limit doesnâ€™t matter

This keeps:

correctness

simplicity

performance

ðŸ§ª Analogy (easy to remember)

Imagine a turnstile ðŸŽ¡:

âŒ Bad:

Look at counter

Decide if you can pass

Then turn it

âœ” Good:

Turn the handle

See if it locked or unlocked

ðŸ Interview one-liner

â€œincrement is atomic, but read-then-increment isnâ€™t, because the decision is made using stale data.â€