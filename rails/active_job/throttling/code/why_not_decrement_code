Short answer (but accurate)

âŒ No â€” DECR itself in Redis is atomic.
âœ… But â€œincrement â†’ check â†’ decrementâ€ as a workflow is not atomic.

That distinction matters a lot.

Letâ€™s separate the two things clearly
1ï¸âƒ£ Redis INCR / DECR commands

These are atomic operations in Redis.

INCR key
DECR key


Redis guarantees:

No two clients can interleave a single command

Each command runs completely before the next

So:

DECR is atomic by itself

2ï¸âƒ£ The problem is the sequence âŒ

This pattern is not atomic:

count = INCR key
if count > limit
  DECR key
end


Why?

Because multiple requests can do this at the same time.

Race condition example (very important)

Assume:

limit = 5

key value = 4

Two requests arrive concurrently:

Req A â†’ INCR â†’ 5
Req B â†’ INCR â†’ 6


Now both see:

count > limit


So both run:

DECR


Final value:

6 â†’ 5 â†’ 4


ğŸ”¥ Now the counter is below the limit again
ğŸ”¥ Next request may pass incorrectly

This is the race condition.

Why Redis canâ€™t â€œhelpâ€ here automatically

Redis guarantees atomicity per command, not per business logic.

Atomicity does not span multiple commands unless:

you use a Lua script

or Redis transactions (with caveats)

Correct mental model ğŸ§ 

| Thing                         | Atomic? |
| ----------------------------- | ------- |
| `INCR key`                    | âœ…       |
| `DECR key`                    | âœ…       |
| `INCR â†’ IF â†’ DECR`            | âŒ       |
| `Rails.cache.increment`       | âœ…       |
| `increment + decrement logic` | âŒ       |


One atomic command

No rollback

No race condition

TTL resets state

If interviewer pushes: â€œCan we make it atomic?â€

Yes â€” with Redis Lua:

local count = redis.call("INCR", KEYS[1])
if count > tonumber(ARGV[1]) then
  return 0
end
return 1


This runs atomically on Redis.

Interview-ready final statement ğŸ¯

Say this:

â€œRedis DECR is atomic, but using INCR followed by conditional DECR is not atomic and causes race conditions under concurrency.â€

That answer is 100% correct and senior-level.



##########


Short answer (but accurate)

âŒ No â€” DECR itself in Redis is atomic.
âœ… But â€œincrement â†’ check â†’ decrementâ€ as a workflow is not atomic.

That distinction matters a lot.

Letâ€™s separate the two things clearly
1ï¸âƒ£ Redis INCR / DECR commands

These are atomic operations in Redis.

INCR key
DECR key


Redis guarantees:

No two clients can interleave a single command

Each command runs completely before the next

So:

DECR is atomic by itself

2ï¸âƒ£ The problem is the sequence âŒ

This pattern is not atomic:

count = INCR key
if count > limit
  DECR key
end


Why?

Because multiple requests can do this at the same time.

Race condition example (very important)

Assume:

limit = 5

key value = 4

Two requests arrive concurrently:

Req A â†’ INCR â†’ 5
Req B â†’ INCR â†’ 6


Now both see:

count > limit


So both run:

DECR


Final value:

6 â†’ 5 â†’ 4


ğŸ”¥ Now the counter is below the limit again
ğŸ”¥ Next request may pass incorrectly

This is the race condition.

Why Redis canâ€™t â€œhelpâ€ here automatically

Redis guarantees atomicity per command, not per business logic.

Atomicity does not span multiple commands unless:

you use a Lua script

or Redis transactions (with caveats)

Correct mental model ğŸ§ 
Thing Atomic?
INCR key  âœ…
DECR key  âœ…
INCR â†’ IF â†’ DECR  âŒ
Rails.cache.increment âœ…
increment + decrement logic âŒ
Why Rails.cache.increment-only is safe
current = Rails.cache.increment(...)
current <= limit


One atomic command

No rollback

No race condition

TTL resets state

If interviewer pushes: â€œCan we make it atomic?â€

Yes â€” with Redis Lua:

local count = redis.call("INCR", KEYS[1])
if count > tonumber(ARGV[1]) then
  return 0
end
return 1


This runs atomically on Redis.

Interview-ready final statement ğŸ¯

Say this:

â€œRedis DECR is atomic, but using INCR followed by conditional DECR is not atomic and causes race conditions under concurrency.â€

That answer is 100% correct and senior-level.

Youâ€™re asking the right questions

This exact confusion trips up many developers â€” your reasoning is solid.