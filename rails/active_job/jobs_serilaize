Your code:

def perform(user)
end


This works, but is NOT recommended.

Why?

Jobs are serialized

Passing full objects can break

Object may be stale

Best practice:
def perform(user_id)
  user = User.find(user_id)
end


Interviewers LOVE this.



##########


âŒ Active Job does NOT use Marshal.dump like Rails.cache
âœ… It uses GlobalIDâ€“based serialization

Letâ€™s break this from zero.

1ï¸âƒ£ What does â€œJobs are serializedâ€ mean?

When you call:

WelcomeEmailJob.perform_later(user)


Rails must:

Convert arguments into JSON-safe data

Store them in Redis

Rebuild them later in another process

This process = serialization â†’ deserialization

2ï¸âƒ£ Does Active Job use Marshal.dump?
âŒ NO

Active Job does not use Marshal.

Why not Marshal?

Ruby-version dependent

Unsafe for untrusted input

Not language-agnostic

Breaks across deployments

Rails intentionally avoids it for jobs.

3ï¸âƒ£ What DOES Active Job use then?
âœ… GlobalID (gid://)

Rails serializes Active Record objects using GlobalID.

4ï¸âƒ£ Example (very important)
Code:
WelcomeEmailJob.perform_later(user)

What gets stored in Redis:
{
  "arguments": [
    {
      "_aj_globalid": "gid://myapp/User/42"
    }
  ]
}


ğŸ“Œ Not the object
ğŸ“Œ Only a reference (class + id)

5ï¸âƒ£ How is the object rebuilt?

When the job runs:

def perform(user)
  # user is reloaded from DB
end


Rails does internally:

GlobalID::Locator.locate("gid://myapp/User/42")
# â†’ User.find(42)

6ï¸âƒ£ Why can objects become stale?

Because:

Job might run minutes or hours later

Database row may have changed

Or deleted

Example:

user.name = "Old Name"
WelcomeEmailJob.perform_later(user)

# later...
user.update(name: "New Name")


Job sees "New Name", not "Old Name".

Thatâ€™s what stale data means.

7ï¸âƒ£ Why passing full objects can still break
a) Object deleted
User.destroy(42)


â¡ï¸ Job fails with ActiveRecord::RecordNotFound

b) Object changed

Business logic becomes inconsistent

c) Non-ActiveRecord objects
perform(OpenStruct.new)


âŒ Cannot be serialized

8ï¸âƒ£ What arguments ARE allowed in Active Job?
âœ… Safe types:

String

Integer

Float

Boolean

Nil

Hash / Array (with safe types)

ActiveRecord objects (via GlobalID)

âŒ Unsafe:

Procs

Lambdas

IO objects

OpenStruct

File handles

Sockets

9ï¸âƒ£ So why still prefer user_id?

Even though GlobalID exists?

Best practice reasons:

Explicit

Avoid stale expectations

Clear failure handling

Easier retries

Less magic

Recommended:
def perform(user_id)
  user = User.find_by(id: user_id)
  return unless user
end


Interviewers LOVE this pattern.

ğŸ”Ÿ Comparison: Active Job vs Rails.cache
Feature Active Job  Rails.cache
Serialization GlobalID / JSON Marshal
Safe across versions  âœ… âŒ
Object reload Yes No
Human-readable  Yes No
1ï¸âƒ£1ï¸âƒ£ Interview killer one-liners

ğŸ’¬ Does Active Job use Marshal?
â¡ï¸ No, it uses GlobalID for ActiveRecord objects.

ğŸ’¬ Why not Marshal?
â¡ï¸ Unsafe, version-dependent, and not portable.

ğŸ’¬ What happens if record is deleted?
â¡ï¸ Job raises RecordNotFound.

ğŸ§  Mental model to lock it in

Active Job stores references, not objects.