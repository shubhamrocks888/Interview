Why canâ€™t we â€œdirectly save dataâ€ (objects) in Rails?
The core reason:

Ruby objects live only in RAM of a single process.

RAM data:

Exists only while the process is running

Cannot be shared between processes

Cannot survive restarts

Cannot be understood by Redis / DB / file systems

Example:

user = User.new(name: "Shubham")


This user object:

Lives in Ruby memory

Has pointers, references, class metadata

Is meaningless outside that Ruby process

What goes wrong if we try to save objects directly?
1ï¸âƒ£ Process Boundary Problem (BIGGEST reason)

Rails app is multi-process:

Web Process        Sidekiq Worker
-----------        ---------------
Ruby memory âŒ  â†’  Ruby memory âŒ


You cannot pass memory references between them.

âŒ This is impossible:

perform_later(user)   # pass live Ruby object


Because:

Sidekiq runs in a different process

That object does not exist there

âœ”ï¸ Serialization converts object â†’ bytes â†’ reconstructable data

2ï¸âƒ£ Persistence Problem (Crash / Restart)

RAM data is temporary.

If server restarts:

All in-memory objects are lost

Jobs, cache, sessions disappear

Serialization allows:

Data stored in Redis / DB / files

Survives crashes & deploys

Object â†’ Serialized bytes â†’ Redis

3ï¸âƒ£ Storage Systems Donâ€™t Understand Ruby Objects

Redis, PostgreSQL, files:

Store strings / bytes

Donâ€™t know Ruby classes, methods, pointers

âŒ Redis cannot store this:

#<User id:1 name:"Shubham">


âœ”ï¸ But it can store:

{"id":1,"name":"Shubham"}


That conversion is serialization.

4ï¸âƒ£ Object Graph & Reference Problem

Ruby objects reference other objects:

user â†’ profile â†’ address â†’ country


Saving this directly means:

Circular references

Huge memory graphs

Hard to reconstruct safely

Serialization flattens this into a safe structure.

5ï¸âƒ£ Versioning & Code Change Problem

If you saved raw objects:

Deploy changes class structure

Old objects break

Example:

class User
  attr_accessor :age
end


Later you remove age â†’ old saved objects crash.

âœ”ï¸ Serialized primitives (id, hash) are stable.

6ï¸âƒ£ Security Risk

Direct object storage can:

Execute arbitrary code when loaded

Cause deserialization vulnerabilities

Rails limits this by:

Using GlobalID

Encouraging primitive data only

So why serialization is REQUIRED?
Serialization solves these problems:
Problem	Without Serialization	With Serialization
Process boundary	âŒ	âœ…
Crash recovery	âŒ	âœ…
Distributed systems	âŒ	âœ…
Storage compatibility	âŒ	âœ…
Version safety	âŒ	âœ…
Retry jobs	âŒ	âœ…
Is it a memory problem?
âŒ Mostly NO

Memory size is not the main issue

Even small objects fail across processes

âœ… Itâ€™s a lifecycle & boundary problem

Memory is local, temporary, and private

Real-world analogy (Interview-friendly)

RAM objects are like open browser tabs
Serialization is like saving a PDF

You can:

Send PDF

Store it

Open it later

Open it on another machine

But you canâ€™t send an open tab

Rails Best Practice (Golden Rule)
# GOOD
perform_later(user.id)

# BAD
perform_later(user)


Rails uses GlobalID internally to safely serialize references.

One-line interview answer ğŸ’¡

We need serialization because Ruby objects live only in process memory.
To persist data, share it across processes, survive restarts, and store it in Redis/DB, we must convert objects into a portable byte format â€” that is serialization.