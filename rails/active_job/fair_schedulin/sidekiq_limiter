Problem (recap)

Sidekiq concurrency = 10

User-1, User-2, User-3 each enqueue 10 report jobs

Requirement: each user should get a fair chance

No user should occupy all workers

âœ… Sidekiq Enterprise solution (CORRECT & CLEAN)

Sidekiq Enterprise gives built-in, crash-safe, Redis-backed rate & concurrency limiters.

ğŸ‘‰ No manual Redis code
ğŸ‘‰ No TTL guessing
ğŸ‘‰ No edge-case bugs

ğŸ§  Core idea

Limit concurrent jobs per user using a concurrency limiter keyed by user_id.

ğŸ§± Worker code (Sidekiq Enterprise)
class ReportGenerationJob
  include Sidekiq::Worker

  sidekiq_options queue: :reports

  def perform(user_id)
    limiter = Sidekiq::Limiter.concurrent(
      "reports:user:#{user_id}",
      1
    )

    limiter.within_limit do
      generate_report(user_id)
    end
  end
end

ğŸ” Line-by-line explanation
1ï¸âƒ£ Sidekiq::Limiter.concurrent
Sidekiq::Limiter.concurrent("reports:user:#{user_id}", 1)


Means:

â€œAllow only 1 job at a time for this key.â€

Key is per user â†’ fairness guaranteed.

2ï¸âƒ£ within_limit
limiter.within_limit do


What happens internally:

If limit is free â†’ job runs

If limit exceeded â†’ job waits in Redis

No busy retry

No manual cleanup

3ï¸âƒ£ Crash safety (IMPORTANT)

If worker crashes:

Sidekiq Enterprise automatically releases slot

Uses Redis + TTL + heartbeats internally

You donâ€™t write any of that code

ğŸ“Š Execution behavior
Time	Worker slots
Start	U1, U2, U3 each get 1 slot
Next	Extra jobs wait
Completion	Next job for that user runs

â¡ï¸ Perfect fairness

ğŸ† Interview-ready explanation (say this)

â€œUsing Sidekiq Enterprise, I would apply a per-user concurrency limiter.
Each user is allowed only one concurrent report job, enforced by Sidekiqâ€™s Redis-backed limiters.
This prevents starvation and is crash-safe out of the box.â€

This is a gold answer.

ğŸ’ Even better: combine with rate limiting
Example

Max 5 reports per hour per user

rate_limiter = Sidekiq::Limiter.rate(
  "reports:user:#{user_id}",
  5,
  1.hour
)

rate_limiter.within_limit do
  generate_report(user_id)
end


You can even combine both:

concurrency.within_limit do
  rate.within_limit do
    generate_report(user_id)
  end
end

â“ If interviewer asks: â€œWhy not open-source Sidekiq?â€

Answer:

â€œOpen-source Sidekiq doesnâ€™t provide fairness or per-key concurrency.
Enterprise solves this safely without custom Redis logic.â€

ğŸ§  What interviewer is REALLY testing
Skill	Demonstrated
Distributed locking	âœ…
Crash safety	âœ…
Fair scheduling	âœ…
Practical tradeoffs	âœ…
Tool knowledge	âœ…
ğŸ Final takeaway

Manual Redis = works but risky

Sidekiq Enterprise = correct, simple, battle-tested

This is how large Rails systems do it