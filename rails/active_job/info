1ï¸âƒ£ First: What is a â€œbackground jobâ€? (Plain English)
Imagine this Rails request:
User clicks "Sign up"
â†’ create user
â†’ send welcome email
â†’ resize avatar image
â†’ notify admin on Slack
â†’ return response


If Rails does everything immediately, the user waits â³
This is bad UX and wastes web server time.

âœ… Solution

Do only the important fast work now
Do slow / non-critical work later â†’ background job

Examples of background work:

Sending emails

Image processing

Reports generation

API calls

Data cleanup

Notifications

ğŸ‘‰ Background job = work done outside the request-response cycle

2ï¸âƒ£ Core idea (one picture in words)
Rails app
   |
   |  "Hey, do this later"
   â†“
Job Queue (Redis)
   |
   |  "I have work!"
   â†“
Worker (Sidekiq)
   |
   |  executes Ruby code
   â†“
Email / API / DB / File


Keep this flow in mind â€” everything else fits here.

3ï¸âƒ£ What is Active Job?
ğŸ”¹ Problem before Active Job

Rails apps used different background libraries:

Sidekiq

Resque

Delayed Job

Each had different APIs â†’ painful to switch.

ğŸ”¹ Solution: Active Job (Rails abstraction)

Active Job is just an interface (wrapper)
It does NOT do jobs itself.

Think of it like:

â€œActive Record for background jobsâ€

What Active Job does:

Defines job classes

Standardizes syntax

Lets you switch backend easily

Example:
class WelcomeEmailJob < ApplicationJob
  queue_as :default

  def perform(user_id)
    UserMailer.welcome(User.find(user_id)).deliver_now
  end
end


Calling it:

WelcomeEmailJob.perform_later(user.id)


âš ï¸ Important:

perform_later does NOT run the job
It enqueues the job

4ï¸âƒ£ What is Sidekiq?
ğŸ”¹ Sidekiq = the engine that actually runs jobs

Sidekiq is:

A background job processor

Uses threads

Very fast

Production-grade

Sidekiq responsibilities:

Pull jobs from Redis

Execute perform

Retry failed jobs

Handle concurrency

Provide Web UI

Without Sidekiq:
âŒ Jobs just sit in queue forever

5ï¸âƒ£ What is Redis?
ğŸ”¹ Redis = fast in-memory data store

In background jobs:

Redis acts as the job queue

Stores:

Job data

Retry info

Schedules

Failures

Why Redis?

Extremely fast

Simple data structures (lists, hashes)

Persistent (can survive restarts if configured)

6ï¸âƒ£ How they are coupled together

Letâ€™s connect the dots clearly ğŸ‘‡

Step-by-step flow
1ï¸âƒ£ User triggers action
WelcomeEmailJob.perform_later(user.id)

2ï¸âƒ£ Active Job

Converts job into JSON

Pushes it to queue adapter

3ï¸âƒ£ Queue adapter = Sidekiq

Rails config:

config.active_job.queue_adapter = :sidekiq

4ï¸âƒ£   

Redis stores:

{
  "class": "WelcomeEmailJob",
  "args": [1],
  "queue": "default"
}

5ï¸âƒ£ Sidekiq worker process

Running in background

Polls Redis

Fetches job

Executes:

perform(user_id)

7ï¸âƒ£ Visual coupling summary
Component	Role
Active Job	Interface / abstraction
Sidekiq	Job processor (worker)
Redis	Job storage / queue
Dependency chain:
Active Job
   â†“
Sidekiq
   â†“
Redis

8ï¸âƒ£ What happens if something fails?
Example: Email service down

Sidekiq:

Catches exception

Retries job automatically

Uses exponential backoff

Stores retry info in Redis

You get:

Automatic retries

Failure tracking

Dead jobs queue

9ï¸âƒ£ Why Active Job if Sidekiq already exists?

Interview-grade answer ğŸ‘‡

Active Job provides a consistent API across background job backends, while Sidekiq provides high-performance execution using Redis.

You can swap Sidekiq later:

:sidekiq â†’ :resque â†’ :delayed_job


without changing job code.

ğŸ”Ÿ Minimal real-world setup
Gemfile
gem "sidekiq"

config/application.rb
config.active_job.queue_adapter = :sidekiq

Run Redis
redis-server

Run Sidekiq
bundle exec sidekiq

1ï¸âƒ£1ï¸âƒ£ Common interview traps (important)
âŒ â€œActive Job runs jobsâ€

â¡ï¸ False

âŒ â€œSidekiq stores jobsâ€

â¡ï¸ False (Redis does)

âŒ â€œRedis is optionalâ€

â¡ï¸ False for Sidekiq

1ï¸âƒ£2ï¸âƒ£ One-line mental model

Active Job defines jobs, Sidekiq runs jobs, Redis stores jobs



######


