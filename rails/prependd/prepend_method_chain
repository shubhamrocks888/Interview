Great question â€” this is exactly how to really understand prepend.
Letâ€™s look at the method lookup chain before and after prepend.

Example setup
module M
  def greet
    "from M"
  end
end

class User
  def greet
    "from User"
  end
end

ðŸ” Method lookup chain BEFORE prepend
No include, no prepend
User.ancestors

[User, Object, Kernel, BasicObject]

Call:
User.new.greet


Output:

"from User"


Ruby checks:

User âœ…

Stops (method found)

ðŸ” Method lookup chain AFTER include
class User
  include M
end

User.ancestors

[User, M, Object, Kernel, BasicObject]

Call:
User.new.greet


Output:

"from User"


Ruby checks:

User âœ…

M âŒ (never reached)

ðŸ‘‰ include does not override class methods.

ðŸ”¥ Method lookup chain AFTER prepend
class User
  prepend M
end

User.ancestors

[M, User, Object, Kernel, BasicObject]

Call:
User.new.greet


Output:

"from M"


Ruby checks:

M âœ…

Stops (unless super is called)

ðŸ” With super in prepended module
module M
  def greet
    "M -> " + super
  end
end


Output:

"M -> from User"


Lookup:

M#greet

super â†’ User#greet

ðŸ§  Visual summary
Before prepend
User
 â†“
Object
 â†“
Kernel
 â†“
BasicObject

After include
User
 â†“
M
 â†“
Object
 â†“
Kernel
 â†“
BasicObject

After prepend
M
 â†“
User
 â†“
Object
 â†“
Kernel
 â†“
BasicObject

Interview-ready one-liner ðŸ§ âœ¨

Before prepend, Ruby looks for methods in the class first. After prepend, the prepended module is searched before the class in the method lookup chain.

Key takeaway

include â†’ module goes after class

prepend â†’ module goes before class

super moves down the ancestor chain