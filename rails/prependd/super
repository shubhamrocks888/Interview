Yes âœ… â€” with include, you can call both methods using super, but only in one specific direction.
Letâ€™s walk it slowly and clearly.

ğŸ”¹ Setup: same method in class and included module
module Trackable
  def save
    puts "module save"
    super
  end
end

class User
  include Trackable

  def save
    puts "class save"
  end
end

User.new.save

âœ… Output
module save
class save

ğŸ§  Why this works

Method lookup order with include:

User
 â†“
Trackable
 â†“
Object


When you call:

User.new.save


Ruby finds save in Trackable first (because include inserts module after the class in the lookup chain).

Inside the moduleâ€™s save:

super


Ruby continues down the chain â†’ finds User#save.

âš ï¸ Important limitation
âŒ You cannot call module method from class using super
class User
  include Trackable

  def save
    puts "class save"
    super   # âŒ NoMethodError
  end
end


Why?

Because after User, Ruby looks in:

Trackable â†’ Object â†’ Kernel


But super only works if a method exists later in the chain.
If the module is before the class (via prepend), then this changes.

ğŸ” Same example with prepend
module Trackable
  def save
    puts "module save"
    super
  end
end

class User
  prepend Trackable

  def save
    puts "class save"
  end
end

Output
module save
class save


Now lookup order:

Trackable
 â†“
User
 â†“
Object

ğŸ§  Rule of thumb (very interview-friendly)
Scenario	Can super call the other method?
include â†’ module calls class	âœ… YES
include â†’ class calls module	âŒ NO
prepend â†’ module calls class	âœ… YES
prepend â†’ class calls module	âŒ NO
ğŸ¯ Interview one-liner

With include, the module method can call the class method using super, but the class cannot call the moduleâ€™s method. With prepend, the module always takes precedence in the lookup chain.