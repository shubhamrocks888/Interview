1Ô∏è‚É£ Basic write / read
	Write
	Rails.cache.write("users_count", 10)

	Read
	Rails.cache.read("users_count")
	# => 10


2Ô∏è‚É£ Write with expiration (VERY common)
	Rails.cache.write("users_count", 10, expires_in: 5.minutes)
	After 5 minutes ‚Üí key disappears.

3Ô∏è‚É£ fetch (MOST IMPORTANT METHOD ‚≠ê)
	Rails.cache.fetch("users_count", expires_in: 5.minutes) do
	  User.count
	end

	What happens

	Cache HIT ‚Üí returns cached value
	Cache MISS ‚Üí runs block, stores result, returns it

	üìå 90% of Rails caching uses fetch

4Ô∏è‚É£ Delete cache
	Rails.cache.delete("users_count")

	Used after updates.

5Ô∏è‚É£ Check if key exists
	Rails.cache.exist?("users_count")


6Ô∏è‚É£ Increment / decrement (numbers only)
	Rails.cache.increment("page_views")
	Rails.cache.decrement("page_views")


	With expiry:

	Rails.cache.increment("page_views", 1, expires_in: 1.hour)

7Ô∏è‚É£ fetch with race condition protection
	Rails.cache.fetch(
	  "expensive_data",
	  expires_in: 10.minutes,
	  race_condition_ttl: 5.seconds
	) do
	  heavy_computation
	end


	Prevents cache stampede.

8Ô∏è‚É£ Namespacing keys (recommended)
	Rails.cache.fetch("users/count") { User.count }


	Use / or : for structure.

10Ô∏è‚É£ Fragment caching (view-level)
	<% cache @user do %>
	  <%= render @user %>
	<% end %>


	Rails auto-generates cache keys.


