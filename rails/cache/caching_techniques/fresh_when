âŒ No â€” fresh_when does NOT â€œupdate the cacheâ€ when there is new data

This is a very common misunderstanding, so youâ€™re asking exactly the right thing ğŸ‘

ğŸ”¹ What fresh_when ACTUALLY does

fresh_when does not store or update any cache.

Instead, it:

Sets HTTP cache validation headers

ETag

Last-Modified

Helps the client (browser / CDN) decide:

â€œDo I need to download this response again?â€

ğŸ”„ How it really works (step-by-step)
First request
def show
  @post = Post.find(params[:id])
  fresh_when @post
end


Rails sends:

ETag: "posts/1-20260120100000"
Last-Modified: Mon, 20 Jan 2026 10:00:00 GMT


Client stores the response.

Second request (no DB change)

Client sends:

If-None-Match: "posts/1-20260120100000"
If-Modified-Since: Mon, 20 Jan 2026 10:00:00 GMT


Rails compares with @post.updated_at.

ğŸ‘‰ Same â†’ 304 Not Modified
ğŸ‘‰ NO response body sent

Third request (data updated)

@post.updated_at changes.

Rails sends:

New ETag

New response body

ğŸ‘‰ Client replaces its cached copy

ğŸ§  Key Insight (Very Important)

fresh_when does not update cache
It only tells the client when to invalidate and re-fetch

Caching happens:

In the browser

In the CDN

In reverse proxies

ğŸ”¥ Comparison (Clear)
Feature	fresh_when
Stores data	âŒ No
Updates cache	âŒ No
Generates headers	âœ… Yes
Returns 304	âœ… Yes
Client controls caching	âœ… Yes
â— What ACTUALLY updates the cache?

Browser replaces cached response

CDN refreshes its copy

Proxy updates stored response

Rails just signals freshness.

ğŸ¯ Interview One-Liner (Perfect)

â€œfresh_when doesnâ€™t cache data itself; it enables conditional HTTP caching by generating ETags and timestamps so clients know when to re-fetch updated content.â€

ğŸ§  Mental Model (Remember this)

expires_in â†’ â€œCache this for X timeâ€

fresh_when â†’ â€œTell me if this changedâ€

Rails.cache â†’ â€œStore this on the serverâ€

Different layers. Different jobs.