1️⃣ What is Fragment Caching?

Fragment caching in Rails is a way to cache only a part of a view instead of the entire page.

Example: You have a blog page with a header, a list of posts, and a sidebar.

The sidebar doesn’t change often, but the posts list changes frequently.

Instead of caching the whole page, you can cache just the sidebar — this is fragment caching.

✅ Benefit: Reduces rendering time and avoids unnecessary database queries, without making dynamic parts stale.

2️⃣ Basic Syntax

Rails provides the cache helper in views:

<% cache @sidebar do %>
  <%= render 'sidebar' %>
<% end %>


@sidebar is usually a model or object.

Rails uses it to generate a cache key automatically.

What happens internally:

Rails generates a cache key for the object.

Usually: "views/#{model_name}/#{id}-#{updated_at}".

Rails checks if cached HTML exists in your cache store.

If yes → returns cached HTML.

If no → renders the block, stores the HTML in the cache, then returns it.

3️⃣ Example: Caching a List of Posts

Suppose you have a @posts variable in your controller:

@posts = Post.all


In your view:

<% @posts.each do |post| %>
  <% cache post do %>
    <%= render post %>
  <% end %>
<% end %>

How it works:

For each post, Rails generates a cache key like:

views/posts/5-2026-01-13-10:00:00


Rails looks in the cache store (Redis, Memcached, MemoryStore).

If found, it inserts the cached HTML.

If not found, it renders the partial, stores it in cache, and serves it.

4️⃣ Cache Key Generation

Rails automatically generates a key based on:

Model class name (post)

Object ID (5)

Object updated timestamp (updated_at)

Example:

post = Post.find(5)
post.cache_key   # => "posts/5-2026-01-13-10:00:00"


If updated_at changes, the key changes automatically, so Rails invalidates old cache.

5️⃣ Russian Doll Caching (Nested Fragment Caching)

You can nest fragments so that inner caches automatically invalidate outer caches.

Example:

<% cache @posts do %>
  <% @posts.each do |post| %>
    <% cache post do %>
      <%= render post %>
    <% end %>
  <% end %>
<% end %>


Outer cache: @posts

Inner cache: each post

Benefit:

If one post updates, only that post fragment is regenerated, not the entire list.

6️⃣ Low-Level Fragment Caching

You can use Rails.cache.fetch to do manual fragment caching:

sidebar_html = Rails.cache.fetch("sidebar", expires_in: 5.minutes) do
  render_to_string(partial: "sidebar")
end

<%= sidebar_html.html_safe %>


Gives more control over expiration, keys, and cache store.

7️⃣ Expiration / Invalidation

Rails fragment caching handles invalidation automatically if you cache model objects:

Example:

<% cache @post do %>
  <%= render @post %>
<% end %>


When @post.updated_at changes → key changes → cache regenerates

Old cache is automatically ignored (garbage collected later)

For manual expiration:

Rails.cache.delete("sidebar")

8️⃣ Configuring the Cache Store

In config/environments/production.rb:

config.cache_store = :redis_cache_store, { url: "redis://localhost:6379/0" }


Rails will store fragment caches in Redis.

9️⃣ Summary Flow of Fragment Caching

Rails sees <% cache obj do %> in the view

Generates a cache key using obj.cache_key

Checks cache store

Cache hit → insert cached HTML

Cache miss → render block, store HTML in cache, insert into view

Object updated → cache_key changes → old cache ignored

Fragment caching is the most common caching technique in Rails because it balances performance and dynamic content perfectly.





####################

What your code does:
<% @posts.each do |post| %>
  <% cache post do %>
    <%= render post %>
  <% end %>
<% end %>


cache post → fragment caching for each individual post, not the whole page. ✅

Rails does not cache page.html here.

What is cached is the HTML generated by <%= render post %> for that single post.

Rails will store each post’s rendered HTML separately in the cache store, keyed by post.cache_key.

So if you have 10 posts:

10 separate fragments are cached

Rails will fetch each fragment independently on the next request

This is actually called Russian doll caching if you wrap them in an outer cache.