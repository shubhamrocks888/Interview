Rails Request Lifecycle (Step-by-Step)
Example request
GET /posts/42

1ï¸âƒ£ Browser â†’ Web Server (Puma)

Browser sends HTTP request

Puma (or Unicorn/Passenger) accepts it

Puma converts the request into a Rack env hash

env = {
  "REQUEST_METHOD" => "GET",
  "PATH_INFO" => "/posts/42",
  "QUERY_STRING" => "",
  ...
}


â¡ï¸ Hands off to Rack

2ï¸âƒ£ Rack Middleware Stack (Request phase)

Rails now passes the request top â†’ bottom through middleware.

Some important ones:

ğŸ”¹ Rack::RequestId

Adds X-Request-Id

Used for logging & tracing

ğŸ”¹ Rack::Runtime

Starts a timer

ğŸ”¹ ActionDispatch::Cookies

Reads cookies from headers

ğŸ”¹ ActionDispatch::Session

Loads session data

ğŸ”¹ Warden (Devise)

Loads current_user

ğŸ”¹ ActionDispatch::ShowExceptions

Wraps request in error handling

ğŸ‘‰ Middleware can:

Modify env

Halt the request and return a response early

3ï¸âƒ£ Routing (Rails Router)

Rails matches the request:

get "/posts/:id", to: "posts#show"


Router decides:

Controller: PostsController

Action: show

Params: { id: "42" }

â¡ï¸ If no match â†’ 404

4ï¸âƒ£ Controller is instantiated

Rails creates controller instance:

PostsController.new


Then sets up:

params

request

response

session

cookies

5ï¸âƒ£ Controller callbacks (before_action)
before_action :authenticate_user!
before_action :set_post


Execution order:

authenticate_user!

set_post

âŒ If a callback renders/redirects â†’ action never runs

6ï¸âƒ£ Controller action executes
def show
  render json: @post
end


Inside the action:

DB queries happen

Business logic runs

Instance variables set

No response yet â€” just building it.

7ï¸âƒ£ View rendering / Serialization

Depending on app type:

Rails API

render json: â†’ uses serializers / to_json

Full Rails app

ERB / HAML template rendered

Layout applied

Response object created:

status  = 200
headers = { "Content-Type" => "application/json" }
body    = ["{...json...}"]

8ï¸âƒ£ Middleware Stack (Response phase)

Response now travels bottom â†’ top through middleware again.

Examples:

ğŸ”¹ Rack::ETag

Adds ETag header

ğŸ”¹ Rack::ConditionalGet

Handles 304 Not Modified

ğŸ”¹ Rack::Runtime

Appends request duration

ğŸ”¹ ActionDispatch::Cookies

Writes cookies

ğŸ”¹ ActionDispatch::ShowExceptions

Converts exceptions into responses

9ï¸âƒ£ Web Server â†’ Browser

Puma sends final response

Browser renders JSON / HTML

Request lifecycle ends ğŸ¯

Lifecycle in one diagram
Browser
  â†“
Puma
  â†“
Rack Middleware (request)
  â†“
Router
  â†“
Controller
  â†“
Action
  â†“
View / Serializer
  â†“
Rack Middleware (response)
  â†“
Puma
  â†“
Browser

Where common things happen (interview cheat sheet)

| Concern            | Where                      |
| ------------------ | -------------------------- |
| Authentication     | Middleware / before_action |
| Sessions & cookies | Middleware                 |
| Params parsing     | ActionDispatch             |
| Routing            | Router                     |
| Business logic     | Controller / Service       |
| DB queries         | Models                     |
| Error handling     | Middleware                 |
| Logging & metrics  | Middleware                 |

Tricky interview questions (with answers)
â“ Can middleware stop a request?

âœ… Yes â€” it can return a response without hitting controller

â“ Does middleware run for every request?

âœ… Yes (assets, health checks, everything)

â“ Where does Devise load current_user?

âœ… In Warden middleware, before controllers run

â“ Where do Sidekiq jobs fit?

ğŸš« They donâ€™t go through middleware
They run outside the HTTP lifecycle

One-line killer answer

A Rails request flows from the web server through Rack middleware, gets routed to a controller action, renders a response, then travels back through middleware before being sent to the client.