ğŸ–¼ Rails + Sentry Exception Flow Diagram
Client Request (API)
        â”‚
        â–¼
Rails Controller Action
        â”‚
        â–¼
    Service Object / Model
        â”‚
        â–¼
  Exception occurs? â”€â”€â”€â”€â”
        â”‚               â”‚
        â”‚ Yes           â”‚ No
        â–¼               â–¼
   Rescue Block?        Return normal response
        â”‚
   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   â”‚         â”‚
  Yes        No
   â”‚         â”‚
   â–¼         â–¼
Capture & log?   Rails default 500
  â”‚
  â–¼
Sentry.capture_exception(e)  â”€â”€â–º Sends error to Sentry Dashboard
  â”‚
  â–¼
Add context (optional)
  â”‚
  â–¼
Sentry Dashboard
  â”œâ”€ Stack Trace
  â”œâ”€ User Info
  â”œâ”€ Tags (order_id, job, etc.)
  â”œâ”€ Extra Data
  â””â”€ Alerts via Email/Slack

ğŸ”¹ How to explain in interview

Client calls API â†’ hits Rails controller

Controller / Service Object runs â†’ might raise exception

Rescue block captures expected exceptions

Optionally logs via Rails.logger

Sends error to Sentry via Sentry.capture_exception

Sentry records: stack trace, tags, extra info, user context

Unexpected exceptions â†’ bubble up â†’ Rails renders 500 + Sentry auto-captures

Interview line:
â€œI capture expected exceptions in rescue blocks, log them, report to Sentry with context, and let unexpected errors bubble up so Rails and Sentry handle them automatically. This keeps monitoring reliable and debugging fast.â€

ğŸ”¹ Bonus tip

You can show async jobs too:

Background Job (Sidekiq)
        â”‚
        â–¼
  Job performs work
        â”‚
Exception? â”€â”€â–º Retry_on / discard_on rules
        â”‚
        â–¼
Sentry.capture_exception(e) (logs + alerts)


Interviewers like it when you mention retry_on / discard_on in Sidekiq jobs.