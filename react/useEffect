ğŸ§© useEffect â€” FROM SCRATCH
1ï¸âƒ£ First: What problem does useEffect solve?
Without useEffect

A React component should only:

calculate JSX

return UI

âŒ But we often need to do extra work:

API calls

logging

timers

subscriptions

DOM updates

These are called side effects.

2ï¸âƒ£ What is a â€œside effectâ€?

Any operation that affects something outside the component render

Examples:

Fetching data

Updating document.title

Setting interval / timeout

Adding event listeners

3ï¸âƒ£ Simple definition (interview-ready)

useEffect lets you run side-effect code after a component renders.

4ï¸âƒ£ Basic syntax
useEffect(() => {
  // side-effect code
}, [dependencies]);


First argument â†’ function (effect)

Second argument â†’ dependency array (controls WHEN it runs)

5ï¸âƒ£ Important rule (VERY IMPORTANT)

ğŸ‘‰ React renders first, then runs useEffect

Never during render.

6ï¸âƒ£ useEffect with NO dependency array
useEffect(() => {
  console.log("Runs on every render");
});

When does it run?

Initial render

Every re-render

âš ï¸ Rarely used (can cause performance issues)

7ï¸âƒ£ useEffect with EMPTY dependency array []
useEffect(() => {
  console.log("Runs only once");
}, []);

When does it run?

After first render only

Equivalent to class component:
componentDidMount()

Common use cases

API call

Initial setup

Analytics

8ï¸âƒ£ useEffect with dependencies [count]
useEffect(() => {
  console.log("Count changed:", count);
}, [count]);

When does it run?

First render

Every time count changes

Equivalent to:
componentDidMount + componentDidUpdate(count)

9ï¸âƒ£ Cleanup function (VERY IMPORTANT)
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Running...");
  }, 1000);

  return () => {
    clearInterval(timer);
  };
}, []);

Cleanup runs when:

Component unmounts

BEFORE next effect runs (dependency change)

Equivalent to:
componentWillUnmount()

ğŸ”Ÿ Real-world example: API call
useEffect(() => {
  fetch("/users")
    .then(res => res.json())
    .then(data => setUsers(data));
}, []);


ğŸ‘‰ Runs once, fetches data

ğŸ§  Mental model (KEY POINT)

Think like this:

Render â†’ Paint UI â†’ Run useEffect


If dependency changes:

Cleanup â†’ Run effect again

âš ï¸ Common mistakes
âŒ Missing dependency
useEffect(() => {
  console.log(count);
}, []); // âŒ count used but not listed

âœ… Correct
useEffect(() => {
  console.log(count);
}, [count]);

âŒ Infinite loop
useEffect(() => {
  setCount(count + 1);
}, [count]);


Why?

Effect updates count

count changes

Effect runs again

ğŸ§ª Visual timeline example
const [count, setCount] = useState(0);

useEffect(() => {
  console.log("Effect ran");
}, [count]);

Timeline

Render #1 â†’ Effect runs

Click â†’ setCount

Render #2 â†’ Effect runs again

ğŸ¯ Interview Questions (VERY COMMON)

Q: Why useEffect runs after render?
A: To keep render phase pure and predictable.

Q: Can we have multiple useEffect hooks?
A: Yes, unlimited. Better separation of concerns.

Q: Is useEffect async?
A: No, but you can call async functions inside it.

ğŸ§  Rails analogy (since you know Rails)

| React     | Rails          |
| --------- | -------------- |
| useEffect | callbacks      |
| []        | after_create   |
| [count]   | after_update   |
| cleanup   | before_destroy |

ğŸ”‘ Summary

useEffect = side effects

Runs AFTER render

Dependency array controls execution

Cleanup prevents memory leaks


#############  Example

Your confusion (rephrased)

If React renders first, and useEffect runs after render,
then why useEffect at all?
Wonâ€™t the UI already be shown?

ğŸ‘‰ YES, UI is shown first â€” and that is exactly the point.

Key idea (ONE LINE)

React shows UI first, then runs side effects so the browser never blocks rendering.

Step-by-step timeline (VERY IMPORTANT)
Code
const [users, setUsers] = useState([]);

useEffect(() => {
  fetch("/users")
    .then(res => res.json())
    .then(data => setUsers(data));
}, []);

ğŸ•’ Timeline
1ï¸âƒ£ First render (BEFORE useEffect)
users = []


UI shows:

<ul>
  <!-- empty -->
</ul>


âœ… UI is visible immediately

2ï¸âƒ£ After render â†’ useEffect runs

Browser is free

JS thread is free

API call starts

ğŸš€ Non-blocking

3ï¸âƒ£ API response arrives
setUsers(data)

4ï¸âƒ£ State update â†’ re-render
users = [{...}, {...}]


UI updates automatically:

<ul>
  <li>User 1</li>
  <li>User 2</li>
</ul>

Soâ€¦ whatâ€™s the benefit? ğŸ¤”
âŒ If API call happened during render
const users = fetch("/users"); // âŒ


Problems:

Blocks rendering

UI freezes

Breaks Reactâ€™s pure render rule

âœ… With useEffect

Render stays fast

Side effects run later

UI updates when data arrives

Very important rule

Render phase must be PURE

No API calls

No subscriptions

No DOM changes

useEffect exists to move side effects OUT of render.

Why React does NOT wait for useEffect

If React waited:

Slow API = slow UI

Bad UX

White screen

React philosophy:

Render something fast, improve it later

Real-world analogy ğŸš—

Think of ordering food in a restaurant:

You sit â†’ UI rendered

Order food â†’ useEffect

Food arrives â†’ state update â†’ UI updates

You donâ€™t wait for food to sit down ğŸ˜‰

Interview-ready answer ğŸ†

React renders the UI first, then runs useEffect so side effects donâ€™t block rendering. When the effect updates state, React re-renders with new data.

Important follow-up concept (next level)

What if you donâ€™t want empty UI?

if (users.length === 0) {
  return <Spinner />;
}


UI still renders â€” just conditionally.

Final clarity sentence (memorize this)

useEffect exists to keep rendering fast and side effects separate from UI calculation.

If you want next, we can cover: