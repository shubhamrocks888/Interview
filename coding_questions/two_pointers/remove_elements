nums = [3,2,2,3], val = 3
Output: 2
nums = [2,2,?,?]


Remove Element â€” what the question is really asking

Typical wording:

â€œGiven an array nums and a value val, remove all instances of val in place and return the number of elements remaining.â€

This sounds simple, but again â€” the wording is doing a lot of work.

Key constraints (read these carefully)
1ï¸âƒ£ Remove in place

âŒ Do NOT create a new array

âŒ Do NOT use extra memory

âœ… Modify the given array

You are allowed to overwrite elements.

2ï¸âƒ£ Order does NOT matter (this is huge)

Most versions explicitly say:

â€œThe order of elements can be changed.â€

This means:

You donâ€™t need to preserve original ordering

You can move elements freely

ğŸ§  This gives you multiple valid strategies.

3ï¸âƒ£ Return the new length, not the array

Just like Remove Duplicates:

Only the first k elements matter

Everything after index k - 1 is irrelevant

Example:

nums = [3,2,2,3], val = 3
Output: 2
nums = [2,2,?,?]


Those ? values donâ€™t matter.

How this differs from Remove Duplicates
Remove Duplicates	Remove Element
Array is sorted	Array may be unsorted
Remove repeated values	Remove a specific value
Keep one copy	Remove all copies
Order matters	Order usually doesnâ€™t

This difference changes pointer strategy.

Mental model (important)

Think of it as:

â€œKeep all elements that are NOT equal to val, and overwrite the array from the front.â€

You are filtering in place.

Two common pointer strategies (conceptual)
ğŸ”¹ Strategy 1: Slow/Fast pointers (order preserved)

One pointer scans

One pointer writes non-val elements

Used when:

Order must be preserved (or you choose to)

ğŸ”¹ Strategy 2: Swap with end (order not preserved)

One pointer from start

One pointer from end

When val found â†’ swap with last element

Shrink array

Used when:

Order doesnâ€™t matter

You want fewer writes

Interviewers love when you mention both.

What interviewers are testing

This question checks if you:

Read constraints carefully

Understand in-place mutation

Can filter without extra memory

Choose the right pointer pattern

Donâ€™t over-engineer

Itâ€™s a discipline + reading comprehension test.

Common mistakes

âŒ Creating a new array

âŒ Using delete or reject

âŒ Returning the array instead of length

âŒ Forgetting that order doesnâ€™t matter

Interview-ready explanation (say this)

â€œI iterate through the array and overwrite elements that are not equal to the target value, returning the count of remaining elements.â€

That explanation is clean and correct ğŸ”¥

Why interviewers like this question

########


def remove_element(nums, val)
  write = 0

  nums.each do |num|
    if num != val
      nums[write] = num
      write += 1
    end
  end

  write
end
