Remove Duplicates from Sorted Array â€” what the question means

Typical wording:

â€œGiven a sorted array, remove the duplicates in place such that each unique element appears only once. Return the number of unique elements.â€

This sounds simpleâ€¦ but the wording is very intentional.

Key constraints hidden in the question
1ï¸âƒ£ The array is sorted

This is the biggest hint.

Because itâ€™s sorted:

All duplicates are next to each other

You never need to search the whole array to find duplicates

ğŸ§  If it wasnâ€™t sorted â†’ this problem would be much harder.

2ï¸âƒ£ â€œRemove duplicates in placeâ€

This means:

âŒ Do NOT create a new array

âŒ Do NOT use extra memory like sets or hashes

âœ… Modify the given array itself

Youâ€™re allowed to overwrite values.

3ï¸âƒ£ â€œReturn the number of unique elementsâ€

This is subtle and important.

They do not care about:

elements beyond that count

cleaning the array length

Only the first k elements must be unique and correct.

Example:

Input:  [1,1,2,2,3]
Output: k = 3
Array:  [1,2,3,?,?]


Those ? values donâ€™t matter.

What the array should look like after

If input is:

[1,1,2,2,3]


After operation:

[1,2,3,2,3]   â† valid


Return:

3


As long as:

array[0..k-1] == [1,2,3]


You pass.

Why this is a two-pointer problem

You need:

one pointer to read values

one pointer to write unique values

This is not start/end â€” itâ€™s slow / fast.

Mental model (very important)

Think like this:

One pointer scans every element (fast)

Another pointer tracks where the next unique value should go (slow)

When you see a new value â†’ write it at slow pointer â†’ move slow

ğŸ§  Youâ€™re compressing the array in place.

What interviewers are testing

This question checks if you:

Understand sorted data advantages

Can modify arrays in place

Know slow/fast pointer pattern

Donâ€™t overuse extra memory

Follow problem constraints strictly

Itâ€™s a discipline test, not a trick.

Common wrong approaches

âŒ Using Set

âŒ Creating a new array

âŒ Deleting elements (expensive)

âŒ Shifting elements one by one

All of these violate constraints.

Interview-ready explanation (say this)

â€œSince the array is sorted, duplicates are adjacent. I use two pointers: one scans the array, and the other tracks the position to write the next unique element. This removes duplicates in place in linear time.â€

That explanation is exactly what interviewers want ğŸ”¥







##########

def remove_duplicates(arr)
  return 0 if arr.empty?

  write = 0

  (1...arr.length).each do |read|
    if arr[read] != arr[write]
      write += 1
      arr[write] = arr[read]
    end
  end

  write + 1
end
