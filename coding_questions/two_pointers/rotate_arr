Perfect — Rotate Array is another classic array manipulation + two-pointer problem. Let’s carefully explain the question and the patterns you need to know.

Rotate Array — what the question means

Typical wording:

“Given an array nums and an integer k, rotate the array to the right (or left) by k steps, in-place.”

Right rotation: elements shift toward higher indices, wrapping around.

Left rotation: elements shift toward lower indices, wrapping around.

Examples
Right rotation
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation: Rotate right by 3 steps

Left rotation
Input: nums = [1,2,3,4,5,6,7], k = 2
Output: [3,4,5,6,7,1,2]
Explanation: Rotate left by 2 steps

Key points

k may be larger than array length

Always do k = k % n

Example: rotating by 10 in a 7-length array → same as rotating by 3

In-place requirement

❌ Don’t create a new array

✅ Modify the existing array

Two common approaches

Reversal algorithm (most common in interviews)

Cyclic replacement (slightly more advanced)

Simple brute-force (shifting one by one) is O(n*k) → inefficient

Reversal algorithm (interview favorite)

Idea:
Rotating an array right by k can be done in three reversals:

Reverse the entire array

Reverse the first k elements

Reverse the remaining n-k elements

Example: [1,2,3,4,5,6,7], k=3

1️⃣ Reverse all → [7,6,5,4,3,2,1]
2️⃣ Reverse first k=3 → [5,6,7,4,3,2,1]
3️⃣ Reverse remaining n-k=4 → [5,6,7,1,2,3,4] ✅

Left rotation

Either rotate right by n-k

Or reverse first k, reverse remaining, reverse all

Why interviewers love this

Tests in-place array manipulation

Shows you understand index manipulation

Efficient → O(n) time, O(1) extra space

Can be adapted for strings, linked lists, etc.

Common mistakes

❌ Using extra arrays

❌ Forgetting to mod k with n

❌ Off-by-one errors in reversing segments

❌ Confusing left vs right rotation

Interview-ready explanation

“I rotate an array in-place by using the reversal algorithm. For right rotation by k: reverse the whole array, then reverse the first k elements, and finally reverse the rest. This shifts elements efficiently in O(n) time and O(1) space.”


#####


# Helper method to reverse a subarray in-place
def reverse_subarray(arr, start_idx, end_idx)
  while start_idx < end_idx
    arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]
    start_idx += 1
    end_idx -= 1
  end
end

# Rotate array to the right by k positions
def rotate_right(arr, k)
  n = arr.length
  return arr if n == 0

  k %= n
  return arr if k == 0

  # Step 1: Reverse entire array
  reverse_subarray(arr, 0, n - 1)
  # Step 2: Reverse first k elements
  reverse_subarray(arr, 0, k - 1)
  # Step 3: Reverse remaining n-k elements
  reverse_subarray(arr, k, n - 1)

  arr
end

# Rotate array to the left by k positions
def rotate_left(arr, k)
  n = arr.length
  return arr if n == 0

  k %= n
  return arr if k == 0

  # Left rotation by k = right rotation by n-k
  rotate_right(arr, n - k)
end

# Example usage
arr1 = [1, 2, 3, 4, 5, 6, 7]
p rotate_right(arr1, 3)  # => [5, 6, 7, 1, 2, 3, 4]

arr2 = [1, 2, 3, 4, 5, 6, 7]
p rotate_left(arr2, 2)   # => [3, 4, 5, 6, 7, 1, 2]

