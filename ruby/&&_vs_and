Short answer: they both mean â€œANDâ€ but behave very differently because of precedence.

1ï¸âƒ£ && â€” high precedence (use this most of the time)

&& binds tightly, like most operators.

a = true && false
# => false


This works exactly how you expect.

Example
result = user.present? && user.admin?


This is safe and predictable.

2ï¸âƒ£ and â€” low precedence (control-flow style)

and has very low precedence, almost like if / unless.

a = true and false
# => true ğŸ˜³


Why?

Ruby parses it like this:

(a = true) and false


So a gets true, and then and false is evaluated separately.

3ï¸âƒ£ The famous gotcha ğŸ”¥
a = false && true
# => false

a = false and true
# => false? NOPE â†’ false assigned first, then `and true`


Letâ€™s break it:

a = false and true
# parsed as:
(a = false) and true


So a is false.

4ï¸âƒ£ Practical rule (VERY IMPORTANT)
âœ… Use && for conditions and expressions
if logged_in && admin
  puts "Access granted"
end

âœ… Use and for control flow
save_user and notify_admin


This reads nicely like English and is intentional.

5ï¸âƒ£ Another real-world Rails example

âŒ Buggy:

user = User.find_by(email: email) and return


Ruby thinks:

(user = User.find_by(...)) and return


âœ… Correct:

user = User.find_by(email: email) || return


OR:

return unless user = User.find_by(email: email)

6ï¸âƒ£ Interview one-liner ğŸ§ 

&& is for logic, and is for flow control.
&& has high precedence, and has low precedence.