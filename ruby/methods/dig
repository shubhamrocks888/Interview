dig in Ruby

dig is used to safely access nested data
ğŸ‘‰ Works with Hash, Array, and combinations of both.

If any level is missing â†’ returns nil instead of raising an error.

âŒ Problem without dig
data[:user][:profile][:email]
# ğŸ’¥ NoMethodError if any key is missing

âœ… Using dig
data.dig(:user, :profile, :email)
# => "test@example.com" or nil


No exceptions. Peaceful Ruby ğŸ§˜â€â™‚ï¸

1ï¸âƒ£ Hash#dig
hash = {
  user: {
    profile: {
      email: "a@b.com"
    }
  }
}

hash.dig(:user, :profile, :email)
# => "a@b.com"

hash.dig(:user, :address, :city)
# => nil

2ï¸âƒ£ Array#dig
arr = [
  { name: "Alice" },
  { name: "Bob" }
]

arr.dig(1, :name)
# => "Bob"

3ï¸âƒ£ Mixed Array + Hash (ğŸ”¥ very common)
response = {
  users: [
    { id: 1, profile: { email: "a@b.com" } },
    { id: 2, profile: { email: "c@d.com" } }
  ]
}

response.dig(:users, 1, :profile, :email)
# => "c@d.com"


Perfect for API responses.

4ï¸âƒ£ dig vs [] chaining
âŒ Old way
data[:a] && data[:a][:b] && data[:a][:b][:c]

âœ… dig
data.dig(:a, :b, :c)


Cleaner. Safer. Less headache.

5ï¸âƒ£ dig vs try (Rails)
user.try(:profile).try(:email)


vs

user.dig(:profile, :email)


ğŸ‘‰ dig:

Ruby native

Works on Hash + Array

No Rails dependency

6ï¸âƒ£ Important edge cases (interview gold ğŸ’)
ğŸš¨ dig does NOT rescue wrong types
hash = { a: 1 }

hash.dig(:a, :b)
# ğŸ’¥ TypeError (Integer does not have #dig)


So:

dig handles nil, not wrong structure

7ï¸âƒ£ dig + safe navigation (&.)
user&.profile&.email


vs

hash.dig(:user, :profile, :email)


ğŸ‘‰ Use:

&. for objects

dig for data structures

One-liner interview answer ğŸ¯

dig safely fetches nested values from Hashes and Arrays, returning nil if any level is missing instead of raising an error.