üóÇ Architect-Level Database Performance & Bottleneck Cheat Sheet
1Ô∏è‚É£ Confirm the Bottleneck

Before touching any optimization, ensure the database is truly the problem.

Metrics to check:

Metric	Why
CPU usage	High ‚Üí expensive queries
Memory	Sorting, caching issues
Disk IO / latency	Reads/writes slow ‚Üí storage or query problem
Active connections	Pool exhaustion ‚Üí throttling needed
Lock waits	Contention ‚Üí slow transactions
Query latency	Endpoints slow due to DB

Tools:

Postgres: pg_stat_activity, pg_stat_statements

MySQL: slow query log, performance_schema

APM: NewRelic, Datadog, AppSignal

2Ô∏è‚É£ Identify Problem Queries

Step 1: Slow query logs

Postgres: log_min_duration_statement

MySQL: slow_query_log

Step 2: Query stats / top offenders

Postgres: pg_stat_statements ‚Üí top N queries by total time

MySQL: performance_schema

Step 3: Execution plan

EXPLAIN or EXPLAIN ANALYZE to check:

Full table scans

Sequential scans

Nested loops

Join costs

Step 4: Frequency √ó cost

High-frequency, high-cost queries ‚Üí highest impact

3Ô∏è‚É£ Common Optimization Techniques
A. Indexing

Single-column, composite, partial indexes

Covering indexes for read-heavy queries

Avoid over-indexing ‚Üí slows writes

B. Query Optimization

Avoid SELECT *

Use proper JOINs

Aggregate carefully

Remove N+1 queries in app layer

C. Caching

Redis / Memcached for hot reads

Materialized views for expensive aggregates

TTL / cache invalidation strategies

D. Read Scaling

Read replicas (Postgres / MySQL)

Route read queries to replicas

Eventually consistent replicas ‚Äî explain trade-offs

E. Write Scaling

Partition / shard tables for horizontal scaling

Queue writes asynchronously where possible

Batch inserts / updates

F. Connection Pooling

Optimize DB pool size

Use PgBouncer (Postgres) or proxy pooling

G. Hardware / Cloud Scaling

Upgrade CPU / RAM / storage IOPS

Multi-AZ deployments for failover

Only after query & schema optimization

4Ô∏è‚É£ Concurrency & Locks

Identify locks / deadlocks ‚Üí may slow all transactions

Long-running transactions ‚Üí break them into smaller units

Optimistic locking for high contention tables

5Ô∏è‚É£ Monitoring & Alerts

Track slow queries over time

Track lock/wait events

Track replication lag (if using replicas)

Track queue depth (for async writes)

6Ô∏è‚É£ Pitfalls / Trade-offs

| Pitfall                                 | Architect Expectation                  |
| --------------------------------------- | -------------------------------------- |
| Blindly scaling vertically              | Costly, doesn‚Äôt fix query inefficiency |
| Too many indexes                        | Slows writes                           |
| Overusing caching                       | Stale or inconsistent data             |
| Sharding incorrectly                    | Complexity, hot partitions             |
| Async writes without consistency checks | Can break correctness                  |
| Ignoring locks / deadlocks              | High latency, unexpected failures      |


7Ô∏è‚É£ Interview-Ready One-Liners

Diagnosis:

‚ÄúI confirm the DB is the bottleneck using metrics, then pinpoint slow/high-frequency queries using slow query logs, stats tables, and execution plans.‚Äù

Optimization:

‚ÄúI optimize queries, add indexes, cache hot reads, batch writes, and monitor impact.‚Äù

Scaling:

‚ÄúI scale reads using replicas, partition writes if needed, and only scale vertically or horizontally after optimizing queries.‚Äù

Trade-offs:

‚ÄúAll optimizations must consider consistency, write overhead, and operational complexity.‚Äù

8Ô∏è‚É£ Architect Drill Follow-ups

How do you handle 1B+ rows efficiently?

How do you prevent hot partitions in sharding?

How do you scale write-heavy tables while maintaining consistency?

How do you prevent deadlocks under high concurrency?

All of these are answered using the diagnose ‚Üí optimize ‚Üí scale ‚Üí monitor ‚Üí trade-offs roadmap.