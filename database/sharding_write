In sharding, writes are distributed across multiple databases. But the important part is how the system decides which DB to write to.

Letâ€™s walk it slowly and cleanly.

Core idea (1 sentence)

In a sharded system, each write goes to exactly one shard, chosen using a shard key.

Step-by-step write flow in sharding
1ï¸âƒ£ Client sends a write request

Example:

Create order for user_id = 123

2ï¸âƒ£ Application calculates shard

Using shard key (user_id):

shard_id = user_id % TOTAL_SHARDS


Example:

123 % 4 = 3

3ï¸âƒ£ Write goes to ONE database only
Shard 3 DB
  â””â”€â”€ INSERT INTO orders ...


âŒ Other shards are not touched
âŒ No fan-out write

Visual picture
           App
            |
     shard(user_id)
            |
    -----------------
    |   |   |   |   |
   DB1 DB2 DB3 DB4 DB5
         â†‘
       write here

Important clarification â—

âŒ Writes do NOT go to all databases
âœ… Writes go to one shard only

This is why sharding scales writes.

Reads in sharding
Targeted read (fast)
SELECT * FROM orders WHERE user_id = 123


â†’ goes to one shard

Global read (slow)
SELECT COUNT(*) FROM orders


â†’ must query all shards

Transactions in sharded DBs
Within one shard
BEGIN
INSERT ...
UPDATE ...
COMMIT


âœ… Easy

Across shards

âŒ Very hard
âŒ Needs 2-phase commit or compensation logic

ğŸ‘‰ Most systems avoid cross-shard transactions.

Why sharding improves write throughput
Single DB	Sharded DB
All writes hit 1 DB	Writes spread across DBs
Write lock contention	Parallel writes
Disk bottleneck	Distributed disks
Common sharding mistake (interview trap âš ï¸)

â€œWe shard by user_id but then query by email.â€

âŒ Bad â€” causes scatter-gather
âœ… Queries must include shard key

Interview-ready answer ğŸ”¥

In sharding, writes are routed to a single database shard using a shard key. Each shard handles writes independently, which allows horizontal write scaling.