PostgreSQL supports:

Composite types

CREATE TYPE address AS (
  street TEXT,
  city TEXT
);


MySQL âŒ does not support reusable composite types.


#######

1ï¸âƒ£ What is a Composite Type in PostgreSQL?

A composite type is a custom data type made of multiple fields, like a struct / object.

CREATE TYPE address AS (
  street TEXT,
  city   TEXT
);


Think of it as:

Address = Struct.new(:street, :city)


but inside the database.

2ï¸âƒ£ How composite types are used
âœ… Use as a column type
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT,
  home_address address
);


Now home_address is not JSON, not separate columns â€” itâ€™s a typed object.

âœ… Insert data
INSERT INTO users (name, home_address)
VALUES (
  'Shubham',
  ROW('MG Road', 'Bangalore')
);


or explicitly:

INSERT INTO users (name, home_address)
VALUES (
  'Shubham',
  ('MG Road', 'Bangalore')
);

âœ… Query composite fields
SELECT
  name,
  (home_address).street,
  (home_address).city
FROM users;


ğŸ‘‰ Dot notation works because Postgres knows the structure.

âœ… Update part of a composite value
UPDATE users
SET home_address.city = 'Pune'
WHERE name = 'Shubham';

3ï¸âƒ£ Why composite types are powerful
ğŸ”¹ Strong typing (unlike JSON)

Postgres validates structure at write time.

âŒ JSON:

{ "street": 123 }


âœ… Composite:

ERROR: invalid input syntax for type text


So:

fixed schema

predictable fields

safer than JSON

ğŸ”¹ Reusability

Define once, reuse everywhere:

CREATE TABLE orders (
  shipping_address address
);

CREATE TABLE vendors (
  office_address address
);


Change structure once, all tables benefit.

ğŸ”¹ Performance

Stored in binary format

Faster than JSON parsing

Smaller storage footprint

4ï¸âƒ£ Composite types vs JSON / JSONB
Feature Composite Type  JSONB
Schema enforced âœ… Yes âŒ No
Reusable  âœ… Yes âŒ No
Indexing  Limited Excellent
Flexibility Low High
ORM support Weak  Good

ğŸ‘‰ Use composite when:

structure is stable

fields are well-defined

ğŸ‘‰ Use JSONB when:

schema evolves often

semi-structured data

5ï¸âƒ£ MySQL âŒ does NOT support reusable composite types
What MySQL supports instead

Basic column types

JSON

Embedded column groups (manual)

But NO equivalent of CREATE TYPE (...).

âŒ What you cannot do in MySQL
CREATE TYPE address AS (
  street TEXT,
  city TEXT
);


â›” Syntax error â€” feature doesnâ€™t exist.

MySQL workaround patterns
ğŸ”¸ Option 1: Duplicate columns everywhere (bad)
users(street, city)
orders(street, city)
vendors(street, city)


âŒ Repetition
âŒ Hard to change
âŒ Error-prone

ğŸ”¸ Option 2: JSON (most common)
address JSON


Pros:

flexible

schema-less

Cons:

no enforced structure

harder validation

weaker relational semantics

ğŸ”¸ Option 3: Separate table (relational way)
addresses(id, street, city)
users(address_id)
orders(address_id)


âœ” normalized
âœ” reusable
âŒ joins required

6ï¸âƒ£ Why PostgreSQL can do this but MySQL canâ€™t
PostgreSQL design philosophy

Object-relational database

First-class types

Extensible type system

Postgres lets you define:

composite types

enums

ranges

custom operators

MySQL design philosophy

Simpler relational model

Fewer type abstractions

JSON instead of schema types

7ï¸âƒ£ Interview-ready explanation (short)

â€œPostgreSQL supports reusable composite types using CREATE TYPE, which lets you define structured, strongly-typed objects like addresses and reuse them across tables. MySQL doesnâ€™t have an equivalent feature, so you must either duplicate columns, use JSON, or normalize into separate tables.â€

8ï¸âƒ£ Rails / ORM reality check âš ï¸

ActiveRecord:

âŒ No native support for composite types

You must use execute SQL

Manual casting / SQL queries

So in Rails apps:

composite types = rare

normalized tables or JSONB = common